<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced Scalable Temporal Blockchain Ledger - Dual Plane Storage</title>
  <style>
    :root {
        --source-color: #3498db;
        --dest-color: #2ecc71;
        --rung-color: #e74c3c;
        --highlight-color: #f1c40f;
        --bg-color-1: #0a0a0f;
        --bg-color-2: #1a1a2e;
        --bg-color-3: #16213e;
        --pixel-glow: #ffffff;
        --fork-color: #9b59b6;
        --payment-color: #16a085;
        --qrcode-color: #2c3e50;
        --success-color: #27ae60;
        --warning-color: #f39c12;
        --error-color: #e74c3c;
        --glass-bg: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
        --shadow-color: rgba(0, 0, 0, 0.3);
        /* New colors for the second hexagon plane */
        --plane2-source-color: #9b59b6;
        --plane2-dest-color: #1abc9c;
        --plane2-connection-color: #e67e22;
        /* Storage status colors */
        --storage-low: #27ae60;
        --storage-medium: #f39c12;
        --storage-high: #e74c3c;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, var(--bg-color-1) 0%, var(--bg-color-2) 50%, var(--bg-color-3) 100%);
      color: #ecf0f1;
      font-size: 14px;
      transition: filter 0.3s ease;
    }
    
    /* Enhanced Glass Morphism Effects */
    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      box-shadow: 0 8px 32px var(--shadow-color);
    }
    
    .glass-strong {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
    }
    
    /* Enhanced Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(5px);
      justify-content: center;
      align-items: center;
      animation: modalFadeIn 0.3s ease;
    }
    
    @keyframes modalFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .modal-content {
      background: linear-gradient(145deg, var(--bg-color-2), var(--bg-color-3));
      padding: 2rem;
      border-radius: 20px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      border: 1px solid var(--glass-border);
      position: relative;
      transform: scale(0.9);
      animation: modalSlideIn 0.3s ease forwards;
    }
    
    @keyframes modalSlideIn {
      to { transform: scale(1); }
    }
    
    /* Enhanced Input Styles */
    .form-input {
      width: 100%;
      padding: 12px 16px;
      margin: 8px 0;
      border-radius: 12px;
      border: 2px solid var(--glass-border);
      background: var(--glass-bg);
      color: white;
      font-size: 1rem;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .form-input:focus {
      border-color: var(--highlight-color);
      box-shadow: 0 0 0 3px rgba(241, 196, 64, 0.2);
      outline: none;
    }
    
    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    /* Enhanced Button Styles */
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #667eea, #764ba2);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover { 
      transform: translateY(-2px); 
      box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--highlight-color), #f39c12);
      box-shadow: 0 4px 15px rgba(241, 196, 64, 0.4);
    }
    
    .btn-success {
      background: linear-gradient(135deg, var(--success-color), #2ecc71);
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
    }
    
    .btn-payment {
      background: linear-gradient(135deg, var(--payment-color), #1abc9c);
      box-shadow: 0 4px 15px rgba(22, 160, 133, 0.4);
    }
    
    .btn-qr {
      background: linear-gradient(135deg, var(--qrcode-color), #34495e);
      box-shadow: 0 4px 15px rgba(44, 62, 80, 0.4);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, var(--error-color), #c0392b);
      box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
    }
    
    .btn-small {
      padding: 8px 16px;
      font-size: 0.8rem;
    }
    
    .btn.active {
      background: linear-gradient(135deg, var(--highlight-color), #f39c12);
      box-shadow: 0 0 25px rgba(241, 196, 64, 0.8);
    }
    
    /* Enhanced Controls */
    #controls {
      padding: 1rem;
      background: var(--glass-bg);
      backdrop-filter: blur(25px);
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
      box-shadow: 0 4px 30px var(--shadow-color);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--glass-bg);
      border-radius: 12px;
      border: 1px solid var(--glass-border);
    }
    
    .control-label {
      font-size: 0.8rem;
      opacity: 0.8;
      font-weight: 500;
    }
    
    /* Enhanced Search and Filter */
    .search-container {
      position: relative;
      min-width: 280px;
    }
    
    .search-input {
      width: 100%;
      padding: 10px 40px 10px 16px;
      border-radius: 12px;
      border: 2px solid var(--glass-border);
      background: var(--glass-bg);
      color: white;
      backdrop-filter: blur(15px);
      transition: all 0.3s ease;
    }
    
    .search-input:focus {
      border-color: var(--highlight-color);
      box-shadow: 0 0 0 3px rgba(241, 196, 64, 0.2);
    }
    
    .search-icon {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0.5;
    }
    
    /* Enhanced Status Display */
    .status-display {
      font-weight: 600;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      font-size: 0.9rem;
    }
    
    /* Enhanced Canvas */
    canvas { 
      display: block; 
      cursor: grab; 
      image-rendering: crisp-edges;
      transition: filter 0.3s ease;
    }
    canvas:active { cursor: grabbing; }
    
    /* Enhanced Panels */
    .panel {
      position: fixed;
      width: 350px;
      background: var(--glass-strong);
      backdrop-filter: blur(25px);
      border-radius: 20px;
      padding: 1.5rem;
      z-index: 150;
      box-shadow: 0 20px 60px var(--shadow-color);
      border: 1px solid var(--glass-border);
      animation: panelSlideIn 0.4s ease;
    }
    
    @keyframes panelSlideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .details-panel {
      left: 20px;
      bottom: 20px;
      display: none;
    }
    
    .wallet-panel {
      right: 20px;
      bottom: 20px;
      display: none;
    }
    
    .analytics-panel {
      right: 20px;
      top: 100px;
      display: none;
    }
    
    .storage-panel {
      right: 20px;
      top: 100px;
      display: none;
    }
    
    .panel h3 { 
      margin-top: 0; 
      border-bottom: 2px solid var(--highlight-color); 
      padding-bottom: 0.5rem;
      color: var(--highlight-color);
      font-size: 1.2rem;
    }
    
    .panel p { 
      margin: 0.5rem 0; 
      line-height: 1.6; 
    }
    
    /* Enhanced Wallet Styles */
    .wallet-balance {
      background: linear-gradient(145deg, rgba(22, 160, 133, 0.2), rgba(22, 160, 133, 0.1));
      padding: 1.5rem;
      border-radius: 16px;
      margin-bottom: 1rem;
      text-align: center;
      border: 1px solid var(--payment-color);
      position: relative;
      overflow: hidden;
    }
    
    .wallet-balance::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(from 0deg, transparent, rgba(22, 160, 133, 0.1), transparent);
      animation: rotate 10s linear infinite;
      z-index: -1;
    }
    
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    
    .balance-amount {
      font-size: 2rem;
      font-weight: 800;
      background: linear-gradient(135deg, #16a085, #1abc9c);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Enhanced QR Code */
    .qrcode-container {
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: white;
      border-radius: 16px;
      display: inline-block;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      position: relative;
    }
    
    .qrcode-container::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--qrcode-color), var(--payment-color));
      border-radius: 18px;
      z-index: -1;
    }
    
    /* Enhanced Notifications */
    .notification {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: linear-gradient(135deg, var(--success-color), #2ecc71);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 200;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(10px);
      max-width: 300px;
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .notification-payment {
      background: linear-gradient(135deg, var(--payment-color), #1abc9c);
    }
    
    .notification-qrcode {
      background: linear-gradient(135deg, var(--qrcode-color), #34495e);
    }
    
    .notification-warning {
      background: linear-gradient(135deg, var(--warning-color), #f39c12);
    }
    
    .notification-error {
      background: linear-gradient(135deg, var(--error-color), #c0392b);
    }
    
    /* Enhanced Info Panel */
    .info-panel {
      position: fixed;
      top: 120px;
      right: 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      padding: 1rem;
      border-radius: 16px;
      border: 1px solid var(--glass-border);
      font-size: 0.9em;
      max-width: 250px;
      box-shadow: 0 10px 30px var(--shadow-color);
    }
    
    /* Performance Indicator */
    .performance-indicator {
      position: fixed;
      top: 20px;
      left: 20px;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      font-size: 0.8rem;
      backdrop-filter: blur(15px);
    }
    
    .fps-counter {
      color: var(--success-color);
      font-weight: 600;
    }
    
    /* Loading Spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: var(--highlight-color);
      animation: spin 0.8s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Transaction Status Badges */
    .tx-status {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .tx-status-pending {
      background: rgba(241, 196, 64, 0.2);
      color: var(--warning-color);
      border: 1px solid var(--warning-color);
    }
    
    .tx-status-completed {
      background: rgba(39, 174, 96, 0.2);
      color: var(--success-color);
      border: 1px solid var(--success-color);
    }
    
    .tx-status-failed {
      background: rgba(231, 76, 60, 0.2);
      color: var(--error-color);
      border: 1px solid var(--error-color);
    }
    
    /* Analytics Charts */
    .chart-container {
      margin: 1rem 0;
      padding: 1rem;
      background: var(--glass-bg);
      border-radius: 12px;
      border: 1px solid var(--glass-border);
    }
    
    .chart-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--highlight-color);
    }
    
    /* Plane Toggle Switch */
    .plane-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      background: var(--glass-bg);
      border-radius: 20px;
      border: 1px solid var(--glass-border);
    }
    
    .toggle-switch {
      position: relative;
      width: 50px;
      height: 24px;
      background: #475569;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .toggle-switch.active {
      background: var(--highlight-color);
    }
    
    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    
    .toggle-switch.active .toggle-slider {
      transform: translateX(26px);
    }
    
    .plane-label {
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    /* Storage Management Styles */
    .storage-meter {
      margin: 1rem 0;
      padding: 1rem;
      background: var(--glass-bg);
      border-radius: 12px;
      border: 1px solid var(--glass-border);
    }
    
    .storage-bar {
      width: 100%;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
      margin: 0.5rem 0;
      position: relative;
    }
    
    .storage-fill {
      height: 100%;
      border-radius: 10px;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .storage-fill::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .storage-fill.low {
      background: var(--storage-low);
    }
    
    .storage-fill.medium {
      background: var(--storage-medium);
    }
    
    .storage-fill.high {
      background: var(--storage-high);
    }
    
    .storage-stats {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }
    
    .storage-allocation {
      display: flex;
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .allocation-option {
      flex: 1;
      padding: 0.5rem;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .allocation-option:hover {
      background: var(--glass-strong);
      transform: translateY(-2px);
    }
    
    .allocation-option.active {
      background: var(--highlight-color);
      color: #000;
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      #controls {
        padding: 0.5rem;
        gap: 0.3rem;
      }
      
      .control-group {
        flex-direction: column;
        gap: 0.3rem;
        padding: 0.3rem;
      }
      
      .btn {
        padding: 8px 12px;
        font-size: 0.8rem;
      }
      
      .search-container {
        min-width: 200px;
      }
      
      .panel {
        width: 300px;
        padding: 1rem;
      }
      
      .modal-content {
        width: 95%;
        padding: 1.5rem;
      }
      
      .plane-toggle {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .storage-allocation {
        flex-direction: column;
      }
    }
    
    /* Dark Theme Toggle - Fixed positioning */
    .theme-toggle {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 200;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(15px);
    }
    
    .theme-toggle:hover {
      background: var(--glass-strong);
      transform: scale(1.1);
    }
    
    /* Shutdown Button */
    .shutdown-button {
      position: fixed;
      top: 20px;
      right: 80px;
      z-index: 200;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(15px);
      color: var(--error-color);
      font-size: 1.2rem;
    }
    
    .shutdown-button:hover {
      background: var(--glass-strong);
      transform: scale(1.1);
      color: var(--error-color);
    }
    
    /* Shutdown Modal */
    .shutdown-modal .modal-content {
      text-align: center;
      max-width: 400px;
    }
    
    .shutdown-modal h2 {
      color: var(--error-color);
      margin-bottom: 1rem;
    }
    
    .shutdown-modal p {
      margin-bottom: 1.5rem;
      line-height: 1.6;
    }
    
    .shutdown-actions {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }
 </style>
</head>
<body>
  <!-- Performance Indicator -->
  <div class="performance-indicator">
    FPS: <span class="fps-counter" id="fpsCounter">60</span> | 
    Blocks: <span id="blockCounter">0</span>
  </div>
  
  <!-- Shutdown Button -->
  <div class="shutdown-button" id="shutdownButton" title="Shutdown Ledger">
    ⏻
  </div>
  
  <!-- Theme Toggle -->
  <div class="theme-toggle" id="themeToggle" title="Toggle Theme">
    🌙
  </div>
  
  <!-- PIN Modal -->
  <div id="pinModal" class="modal">
    <div class="modal-content">
      <h2>🔐 Secure Access</h2>
      <input type="password" id="pinInput" class="form-input" maxlength="4" placeholder="Enter 4-digit PIN">
      <div id="pinMessage" style="margin: 1rem 0; color: var(--warning-color);"></div>
      <button id="pinSubmit" class="btn btn-primary">Access Ledger</button>
    </div>
  </div>
  
  <!-- Shutdown Modal -->
  <div id="shutdownModal" class="modal shutdown-modal">
    <div class="modal-content">
      <h2>⚠️ Shutdown Ledger</h2>
      <p>Are you sure you want to shutdown the Direct Ledger Wallet? This will:</p>
      <ul style="text-align: left; margin: 1rem 0;">
        <li>Save all transactions to local storage</li>
        <li>Clear the current session</li>
        <li>Require PIN to access again</li>
      </ul>
      <div class="shutdown-actions">
        <button id="cancelShutdown" class="btn">Cancel</button>
        <button id="confirmShutdown" class="btn btn-danger">Shutdown</button>
      </div>
    </div>
  </div>
  
  <!-- Transaction Modal -->
  <div id="txModal" class="modal">
    <div class="modal-content">
      <button id="closeTxModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>✨ Add Transaction</h2>
      <form id="txForm">
        <label class="control-label">From:</label>
        <input type="text" id="txFrom" class="form-input" required>
        
        <label class="control-label">To:</label>
        <input type="text" id="txTo" class="form-input" required>
        
        <label class="control-label">Amount:</label>
        <input type="number" id="txAmount" class="form-input" step="0.01" min="0.01" required>
        
        <label class="control-label">Description:</label>
        <input type="text" id="txDesc" class="form-input" placeholder="Optional description">
        
        <label class="control-label">Target Plane:</label>
        <select id="txPlane" class="form-input">
          <option value="auto">Auto (Recommended)</option>
          <option value="1">Plane 1</option>
          <option value="2">Plane 2</option>
        </select>
        
        <button type="submit" class="btn btn-success" style="margin-top: 1rem;">Add Transaction</button>
      </form>
    </div>
  </div>
  
  <!-- Payment Modal -->
  <div id="paymentModal" class="modal">
    <div class="modal-content">
      <button id="closePaymentModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>💳 DirectLedger Payment</h2>
      <div class="wallet-balance">
        <h3>Your Balance</h3>
        <div class="balance-amount" id="walletBalance">$0.00</div>
      </div>
      <form id="paymentForm">
        <label class="control-label">Recipient ID:</label>
        <input type="text" id="paymentRecipient" class="form-input" placeholder="Enter recipient's wallet ID" required>
        
        <label class="control-label">Amount:</label>
        <input type="number" id="paymentAmount" class="form-input" step="0.01" min="0.01" required>
        
        <label class="control-label">Note (optional):</label>
        <input type="text" id="paymentNote" class="form-input" placeholder="What's this payment for?">
        
        <label class="control-label">Transfer Speed:</label>
        <select id="paymentSpeed" class="form-input">
          <option value="instant">⚡ Instant (0.5% fee)</option>
          <option value="fast" selected>🚀 Fast (0.2% fee)</option>
          <option value="standard">📦 Standard (no fee)</option>
        </select>
        
        <button type="submit" class="btn btn-payment" style="margin-top: 1rem;">Send Payment</button>
      </form>
    </div>
  </div>
  
  <!-- QR Code Modal -->
  <div id="qrcodeModal" class="modal">
    <div class="modal-content" style="text-align: center;">
      <button id="closeQRModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>📱 Payment QR Code</h2>
      <div class="qrcode-container">
        <canvas id="qrcodeCanvas" width="200" height="200"></canvas>
      </div>
      <div style="margin-top: 1rem; font-size: 1.1rem;">
        <div>Amount: <span style="font-weight: bold; color: var(--payment-color); font-size: 1.3rem;" id="qrAmount">$0.00</span></div>
        <div style="margin-top: 0.5rem;">To: <span id="qrRecipient" style="font-family: monospace;">Your Wallet</span></div>
      </div>
      <p style="margin-top: 1rem; opacity: 0.8;">Show this QR code to the payer or share it with them</p>
    </div>
  </div>
  
  <!-- Scan QR Code Modal -->
  <div id="scanModal" class="modal">
    <div class="modal-content" style="text-align: center;">
      <button id="closeScanModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>📷 Scan QR Code</h2>
      <div style="margin: 1.5rem 0; height: 300px; background: rgba(0,0,0,0.3); border-radius: 16px; display: flex; justify-content: center; align-items: center; border: 2px dashed var(--qrcode-color);">
        <div style="color: var(--qrcode-color); font-size: 1.2rem; text-align: center;">
          <div style="font-size: 3rem;">📷</div>
          <div style="margin-top: 1rem;">Point camera at QR code</div>
        </div>
      </div>
      <p style="opacity: 0.8; font-size: 0.9rem;">Camera access would be implemented in a real application</p>
      <button id="simulateScan" class="btn btn-qr">Simulate QR Scan</button>
    </div>
  </div>
  
  <div id="analyticsModal" class="modal">
    <div class="modal-content">
      <button id="closeAnalyticsModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>📊 Analytics Dashboard</h2>
      <div class="chart-container">
        <h4 class="chart-title">Transaction Volume</h4>
        <canvas id="volumeChart" width="600" height="200"></canvas>
      </div>
      <div class="chart-container">
        <h4 class="chart-title">Transaction Types</h4>
        <canvas id="typeChart" width="300" height="200"></canvas>
      </div>
    </div>
  </div>
  
  <!-- Storage Management Modal -->
  <div id="storageModal" class="modal">
    <div class="modal-content">
      <button id="closeStorageModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>💾 Storage Management</h2>
      
      <div class="storage-meter">
        <h4>Plane 1 Storage</h4>
        <div class="storage-bar">
          <div class="storage-fill" id="storageBar1"></div>
        </div>
        <div class="storage-stats">
          <span id="storageUsed1">0</span> / <span id="storageCapacity1">10,000</span> transactions
        </div>
      </div>
      
      <div class="storage-meter">
        <h4>Plane 2 Storage</h4>
        <div class="storage-bar">
          <div class="storage-fill" id="storageBar2"></div>
        </div>
        <div class="storage-stats">
          <span id="storageUsed2">0</span> / <span id="storageCapacity2">10,000</span> transactions
        </div>
      </div>
      
      <div class="storage-meter">
        <h4>Total System Storage</h4>
        <div class="storage-bar">
          <div class="storage-fill" id="storageBarTotal"></div>
        </div>
        <div class="storage-stats">
          <span id="storageUsedTotal">0</span> / <span id="storageCapacityTotal">20,000</span> transactions
        </div>
      </div>
      
      <div style="margin: 1.5rem 0;">
        <h4>Storage Allocation Strategy</h4>
        <div class="storage-allocation">
          <div class="allocation-option active" data-strategy="balanced">
            <div style="font-weight: bold;">Balanced</div>
            <div style="font-size: 0.8rem; opacity: 0.8;">Distribute evenly</div>
          </div>
          <div class="allocation-option" data-strategy="priority">
            <div style="font-weight: bold;">Priority</div>
            <div style="font-size: 0.8rem; opacity: 0.8;">Plane 1 first</div>
          </div>
          <div class="allocation-option" data-strategy="efficiency">
            <div style="font-weight: bold;">Efficiency</div>
            <div style="font-size: 0.8rem; opacity: 0.8;">Fill sequentially</div>
          </div>
        </div>
      </div>
      
      <div style="display: flex; gap: 1rem;">
        <button id="optimizeStorage" class="btn btn-primary" style="flex: 1;">Optimize Storage</button>
        <button id="clearPlane1" class="btn btn-danger" style="flex: 1;">Clear Plane 1</button>
        <button id="clearPlane2" class="btn btn-danger" style="flex: 1;">Clear Plane 2</button>
      </div>
    </div>
  </div>
  
  <!-- Main Controls -->
  <div id="controls" class="glass">
    <div class="control-group">
      <button id="addTxButton" class="btn">✨ Add Transaction</button>
      <button id="generateButton" class="btn">🌌 Generate Galaxy</button>
      <button id="clearButton" class="btn">🗑️ Clear Ledger</button>
    </div>
    
    <div class="control-group">
      <button id="paymentButton" class="btn btn-payment">💳 Payment</button>
      <button id="walletButton" class="btn btn-payment">👛 Wallet</button>
      <button id="analyticsButton" class="btn">📊 Analytics</button>
      <button id="storageButton" class="btn">💾 Storage</button>
      <!-- FIXED: Added commodity button to controls -->
      <button id="commodityButton" class="btn">🪙 Commodities</button>
    </div>
    
    <div class="control-group">
      <button id="generateQRButton" class="btn btn-qr">📱 Generate QR</button>
      <button id="scanQRButton" class="btn btn-qr">📷 Scan QR</button>
    </div>
    
    <div class="control-group">
      <button id="historyModeButton" class="btn">⏳ History Mode</button>
      <button id="forkButton" class="btn">🔀 Fork Timeline</button>
    </div>
    
    <!-- Plane Toggle Control -->
    <div class="control-group plane-toggle">
      <span class="plane-label" id="planeLabel">Plane 1</span>
      <div class="toggle-switch" id="planeToggle">
        <div class="toggle-slider"></div>
      </div>
    </div>
    
    <div class="control-group search-container">
      <input type="search" id="searchBox" class="search-input" placeholder="Search transactions...">
      <span class="search-icon">🔍</span>
    </div>
    
    <div class="control-group">
      <select id="filterSelect" class="form-input" style="min-width: 140px;">
        <option value="all">All Types</option>
        <option value="source">Source Only</option>
        <option value="destination">Destination Only</option>
        <option value="payment">Payments Only</option>
        <option value="qrcode">QR Payments</option>
      </select>
    </div>
    
    <div class="control-group">
      <button id="saveButton" class="btn">💾 Save</button>
      <button id="loadButton" class="btn">📂 Load</button>
    </div>
    
    <div class="control-group">
      <label class="control-label">Zoom:</label>
      <input type="range" id="zoomSlider" min="0.1" max="5" value="1" step="0.1" style="width: 80px;" />
      <span class="status-display" id="zoomDisplay">1.0x</span>
    </div>
    
    <div class="control-group">
      <span class="status-display" id="countDisplay">Transactions: 0</span>
    </div>
  </div>
  
  <!-- Info Panel -->
  <div class="info-panel" id="zoomInfo">
    <strong>Galaxy View</strong><br>
    Each pixel represents a transaction. Zoom in for more details.
  </div>
  
  <!-- Canvas -->
  <canvas id="canvas"></canvas>
  
  <!-- Details Panel -->
  <div id="detailsPanel" class="panel details-panel">
    <h3>Transaction Details</h3>
    <p><strong>ID:</strong> <span id="detailId"></span></p>
    <p><strong>From:</strong> <span id="detailFrom" style="color: var(--source-color);"></span></p>
    <p><strong>To:</strong> <span id="detailTo" style="color: var(--dest-color);"></span></p>
    <p><strong>Amount:</strong> <span id="detailAmount" style="color: var(--rung-color); font-weight: bold;"></span></p>
    <p><strong>Description:</strong> <span id="detailDesc"></span></p>
    <p><strong>Status:</strong> <span id="detailStatus"></span></p>
    <p><strong>Plane:</strong> <span id="detailPlane"></span></p>
    <p><strong>Timestamp:</strong> <span id="detailTs"></span></p>
    <div id="historyActions" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--glass-border);">
      <button onclick="moveTransaction()" class="btn btn-small">📋 Move</button>
      <button onclick="deleteTransaction()" class="btn btn-small" style="margin: 0 0.5rem;">❌ Delete</button>
      <button onclick="forkFromHere()" class="btn btn-small">🔀 Fork Here</button>
      <button onclick="moveToOtherPlane()" class="btn btn-small">🔄 Move Plane</button>
    </div>
  </div>
  
  <!-- Replace the existing Wallet Panel with this updated version -->
  <div id="walletPanel" class="panel wallet-panel">
    <h3>💳 DirectLedger Wallet</h3>
    <div class="wallet-balance">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Wallet ID</div>
      <div id="walletId" style="font-family: monospace; word-break: break-all; font-weight: bold; font-size: 0.9rem;">DL-XXXX-XXXX-XXXX</div>
    </div>
    <div class="wallet-balance">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Available Balance</div>
      <div id="walletPanelBalance" class="balance-amount">$0.00</div>
    </div>
    <div class="wallet-balance" style="margin-top: 1rem;">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Gold Holdings</div>
      <div id="goldBalance" style="font-weight: bold; color: #FFD700;">0.0000 Au ($0.00)</div>
    </div>
    <div class="wallet-balance" style="margin-top: 1rem;">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Silver Holdings</div>
      <div id="silverBalance" style="font-weight: bold; color: #C0C0C0;">0.0000 Ag ($0.00)</div>
    </div>
    <div style="margin-bottom: 1rem;">
      <h4 style="margin: 1rem 0 0.5rem 0; color: var(--payment-color);">Recent Payments</h4>
      <div id="recentPayments" style="max-height: 200px; overflow-y: auto; background: var(--glass-bg); border-radius: 12px; padding: 0.5rem;">
        <p style="opacity: 0.6; text-align: center; margin: 1rem;">No payments yet</p>
      </div>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button onclick="openPaymentModal()" class="btn btn-payment" style="flex: 1;">Send Money</button>
      <button onclick="addFunds()" class="btn btn-success" style="flex: 1;">Add Funds</button>
    </div>
  </div>
  
  <!-- Storage Panel -->
  <div id="storagePanel" class="panel storage-panel">
    <h3>💾 Storage Management</h3>
    <div class="storage-meter">
      <h4>Plane 1</h4>
      <div class="storage-bar">
        <div class="storage-fill" id="panelStorageBar1"></div>
      </div>
      <div class="storage-stats">
        <span id="panelStorageUsed1">0</span> / <span id="panelStorageCapacity1">10,000</span>
      </div>
    </div>
    
    <div class="storage-meter">
      <h4>Plane 2</h4>
      <div class="storage-bar">
        <div class="storage-fill" id="panelStorageBar2"></div>
      </div>
      <div class="storage-stats">
        <span id="panelStorageUsed2">0</span> / <span id="panelStorageCapacity2">10,000</span>
      </div>
    </div>
    
    <div class="storage-meter">
      <h4>Total System</h4>
      <div class="storage-bar">
        <div class="storage-fill" id="panelStorageBarTotal"></div>
      </div>
      <div class="storage-stats">
        <span id="panelStorageUsedTotal">0</span> / <span id="panelStorageCapacityTotal">20,000</span>
      </div>
    </div>
    
    <div style="margin-top: 1rem;">
      <h4>Allocation Strategy</h4>
      <div id="panelAllocationStrategy" style="font-weight: bold; color: var(--highlight-color);">Balanced</div>
    </div>
    
    <div style="margin-top: 1rem;">
      <button onclick="openStorageModal()" class="btn btn-primary" style="width: 100%;">Manage Storage</button>
    </div>
  </div>
  
  <!-- Commodity panel -->
<div id="commodityPanel" class="panel commodity-panel">
  <h3>🪙 Commodity Trading</h3>
  <div class="commodity-prices">
    <div id="goldPrice" style="margin: 10px 0; font-weight: bold;">Gold: $0.00/oz</div>
    <div id="silverPrice" style="margin: 10px 0; font-weight: bold;">Silver: $0.00/oz</div>
  </div>
  <div class="commodity-actions">
    <div style="margin-top: 15px;">
      <button id="buyGoldButton" class="btn">Buy Gold</button>
      <button id="sellGoldButton" class="btn">Sell Gold</button>
    </div>
    <div style="margin-top: 10px;">
      <button id="buySilverButton" class="btn">Buy Silver</button>
      <button id="sellSilverButton" class="btn">Sell Silver</button>
    </div>
  </div>
</div>
  
  <!-- Analytics Panel -->
  <div id="analyticsPanel" class="panel analytics-panel">
    <h3>📊 Real-time Analytics</h3>
    <div class="chart-container">
      <div class="chart-title">Transaction Rate</div>
      <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-color);" id="txRate">0 tx/min</div>
    </div>
    <div class="chart-container">
      <div class="chart-title">Total Volume</div>
      <div style="font-size: 1.3rem; font-weight: bold; color: var(--payment-color);" id="totalVolume">$0.00</div>
    </div>
    <div class="chart-container">
      <div class="chart-title">Network Health</div>
      <div style="display: flex; align-items: center; gap: 0.5rem;">
        <div id="networkHealth" style="width: 12px; height: 12px; border-radius: 50%; background: var(--success-color);"></div>
        <span id="networkStatus">Healthy</span>
      </div>
    </div>
    <div class="chart-container">
      <div class="chart-title">Active Wallets</div>
      <div style="font-size: 1.1rem; font-weight: bold;" id="activeWallets">0</div>
    </div>
  </div>
  
  <!-- Notification Container -->
  <div id="notification" class="notification"></div>
  
  <script>
    /**
     * Enhanced Scalable Temporal Blockchain Ledger
     * Dual Plane Storage System with Real Additional Capacity
     * 
     * @version 3.1.0
     * @author Enhanced by Claude
     * @license MIT
     */
    'use strict';
    // ======================
    // Enhanced State Management
    // ======================
    class LedgerState {
      constructor() {
        // Separate transaction storage for each plane
        this.transactions1 = [];  // Plane 1 transactions
        this.transactions2 = [];  // Plane 2 transactions
        this.blocks1 = [];        // Plane 1 blocks
        this.blocks2 = [];        // Plane 2 blocks
        
        this.userWallet = {
          id: '',
          balance: 0,
          transactions: [],
          commodityBalances: {
            gold: 0,    // Balance in gold tokens
            silver: 0   // Balance in silver tokens
          }
        };
        
        this.currentQRCode = {
          recipient: '',
          amount: 0,
          note: '',
          timestamp: null
        };
        
        this.ui = {
          zoom: 1.0,
          dragOffset: { x: 0, y: 0 },
          dragging: false,
          lastMousePos: { x: 0, y: 0 },
          hoveredBlockIndex: -1,
          selectedTxId: null,
          searchQuery: '',
          filterType: 'all',
          historyMode: false,
          needsRedraw: true,
          animationFrameId: null,
          isAuthenticated: false,
          darkTheme: true,
          isShuttingDown: false,
          currentPlane: 1 // Track which plane is currently visible (1 or 2)
        };
        
        this.performance = {
          fps: 60,
          frameCount: 0,
          lastFpsUpdate: Date.now(),
          renderTime: 0,
          blockPool: []
        };
        
        this.analytics = {
          txRate: 0,
          totalVolume: 0,
          activeWallets: new Set(),
          networkHealth: 'healthy'
        };
        
        this.commodities = {
          gold: {
            name: "Gold",
            symbol: "Au",
            totalReserve: 1000,      // Total ounces in reserve
            pricePerOunce: 1800,     // Current market price in fiat
            tokensInCirculation: 0,  // Number of tokens backed by gold
            reserveRatio: 1.0        // 100% backed
          },
          silver: {
            name: "Silver",
            symbol: "Ag",
            totalReserve: 10000,     // Total ounces in reserve
            pricePerOunce: 25,       // Current market price in fiat
            tokensInCirculation: 0,  // Number of tokens backed by silver
            reserveRatio: 1.0        // 100% backed
          }
        };
        
        // Storage configuration
        this.storage = {
          plane1: {
            capacity: 10000,  // Max transactions per plane
            used: 0,
            transactions: []
          },
          plane2: {
            capacity: 10000,  // Max transactions per plane
            used: 0,
            transactions: []
          },
          allocationStrategy: 'balanced', // balanced, priority, efficiency
          totalCapacity: 20000  // Combined capacity
        };
      }
      
      // Helper method to get current plane data
      getCurrentPlaneData() {
        return {
          transactions: this.ui.currentPlane === 1 ? this.transactions1 : this.transactions2,
          blocks: this.ui.currentPlane === 1 ? this.blocks1 : this.blocks2,
          storage: this.ui.currentPlane === 1 ? this.storage.plane1 : this.storage.plane2
        };
      }
      
      // Helper method to get other plane data
      getOtherPlaneData() {
        return {
          transactions: this.ui.currentPlane === 1 ? this.transactions2 : this.transactions1,
          blocks: this.ui.currentPlane === 1 ? this.blocks2 : this.blocks1,
          storage: this.ui.currentPlane === 1 ? this.storage.plane2 : this.storage.plane1
        };
      }
      
      // Get all transactions from both planes
      getAllTransactions() {
        return [...this.transactions1, ...this.transactions2];
      }
      
      // Get total storage usage
      getTotalStorageUsage() {
        return this.storage.plane1.used + this.storage.plane2.used;
      }
    }
    
    const state = new LedgerState();
    
    // ======================
    // Storage Management System
    // ======================
    class StorageManager {
      static allocateTransaction(txData, targetPlane = 'auto') {
        let plane;
        
        if (targetPlane === 'auto') {
          // Use allocation strategy
          plane = this.getOptimalPlane();
        } else {
          plane = parseInt(targetPlane);
        }
        
        // Check if plane has capacity
        if (!this.hasCapacity(plane)) {
          // Try the other plane
          plane = plane === 1 ? 2 : 1;
          
          if (!this.hasCapacity(plane)) {
            throw new Error('Both planes at full capacity');
          }
        }
        
        return plane;
      }
      
      static getOptimalPlane() {
        const strategy = state.storage.allocationStrategy;
        const plane1Usage = state.storage.plane1.used / state.storage.plane1.capacity;
        const plane2Usage = state.storage.plane2.used / state.storage.plane2.capacity;
        
        switch (strategy) {
          case 'balanced':
            // Allocate to the plane with more available space
            return plane1Usage <= plane2Usage ? 1 : 2;
            
          case 'priority':
            // Always try Plane 1 first, then Plane 2
            return state.storage.plane1.used < state.storage.plane1.capacity ? 1 : 2;
            
          case 'efficiency':
            // Fill planes sequentially
            return state.storage.plane1.used < state.storage.plane1.capacity ? 1 : 2;
            
          default:
            return 1;
        }
      }
      
      static hasCapacity(plane) {
        const storage = plane === 1 ? state.storage.plane1 : state.storage.plane2;
        return storage.used < storage.capacity;
      }
      
      static addTransactionToPlane(txData, plane) {
        const storage = plane === 1 ? state.storage.plane1 : state.storage.plane2;
        const transactions = plane === 1 ? state.transactions1 : state.transactions2;
        const blocks = plane === 1 ? state.blocks1 : state.blocks2;
        
        // Add to storage
        transactions.push(txData);
        storage.transactions.push(txData.id);
        storage.used = transactions.length;
        
        // Create blocks
        blocks.push({ type: 'source', txId: txData.id, data: txData, plane: plane });
        blocks.push({ type: 'destination', txId: txData.id, data: txData, plane: plane });
        
        // Update analytics
        state.analytics.activeWallets.add(txData.from);
        state.analytics.activeWallets.add(txData.to);
        state.analytics.totalVolume += parseFloat(txData.fiatValue || txData.amount);
        
        // Update storage UI
        this.updateStorageUI();
      }
      
      static removeTransaction(txId) {
        // Find and remove from both planes
        let removed = false;
        
        for (let plane = 1; plane <= 2; plane++) {
          const transactions = plane === 1 ? state.transactions1 : state.transactions2;
          const blocks = plane === 1 ? state.blocks1 : state.blocks2;
          const storage = plane === 1 ? state.storage.plane1 : state.storage.plane2;
          
          const txIndex = transactions.findIndex(t => t.id === txId);
          if (txIndex !== -1) {
            const tx = transactions[txIndex];
            
            // Remove from transactions
            transactions.splice(txIndex, 1);
            
            // Remove from storage tracking
            const storageIndex = storage.transactions.indexOf(txId);
            if (storageIndex !== -1) {
              storage.transactions.splice(storageIndex, 1);
            }
            storage.used = transactions.length;
            
            // Remove blocks
            state.blocks1 = state.blocks1.filter(b => b.txId !== txId);
            state.blocks2 = state.blocks2.filter(b => b.txId !== txId);
            
            // Update analytics
            state.analytics.totalVolume -= parseFloat(tx.fiatValue || tx.amount);
            
            removed = true;
          }
        }
        
        if (removed) {
          this.updateStorageUI();
        }
        
        return removed;
      }
      
      static moveTransactionToPlane(txId, targetPlane) {
        // Find the transaction
        let tx = null;
        let sourcePlane = null;
        
        for (let plane = 1; plane <= 2; plane++) {
          const transactions = plane === 1 ? state.transactions1 : state.transactions2;
          const foundTx = transactions.find(t => t.id === txId);
          if (foundTx) {
            tx = foundTx;
            sourcePlane = plane;
            break;
          }
        }
        
        if (!tx || sourcePlane === targetPlane) {
          return false;
        }
        
        // Check capacity
        if (!this.hasCapacity(targetPlane)) {
          NotificationManager.show(`Plane ${targetPlane} is at full capacity!`, 'error');
          return false;
        }
        
        // Remove from source plane
        const sourceTransactions = sourcePlane === 1 ? state.transactions1 : state.transactions2;
        const sourceStorage = sourcePlane === 1 ? state.storage.plane1 : state.storage.plane2;
        const sourceIndex = sourceTransactions.findIndex(t => t.id === txId);
        
        if (sourceIndex !== -1) {
          sourceTransactions.splice(sourceIndex, 1);
          const storageIndex = sourceStorage.transactions.indexOf(txId);
          if (storageIndex !== -1) {
            sourceStorage.transactions.splice(storageIndex, 1);
          }
          sourceStorage.used = sourceTransactions.length;
        }
        
        // Add to target plane
        this.addTransactionToPlane(tx, targetPlane);
        
        // Update blocks
        state.blocks1 = state.blocks1.filter(b => b.txId !== txId);
        state.blocks2 = state.blocks2.filter(b => b.txId !== txId);
        
        const targetBlocks = targetPlane === 1 ? state.blocks1 : state.blocks2;
        targetBlocks.push({ type: 'source', txId: tx.id, data: tx, plane: targetPlane });
        targetBlocks.push({ type: 'destination', txId: tx.id, data: tx, plane: targetPlane });
        
        this.updateStorageUI();
        NotificationManager.show(`Transaction moved to Plane ${targetPlane}`, 'success');
        
        return true;
      }
      
      static clearPlane(plane) {
        if (plane === 1) {
          state.transactions1 = [];
          state.blocks1 = [];
          state.storage.plane1.used = 0;
          state.storage.plane1.transactions = [];
        } else {
          state.transactions2 = [];
          state.blocks2 = [];
          state.storage.plane2.used = 0;
          state.storage.plane2.transactions = [];
        }
        
        this.updateStorageUI();
        NotificationManager.show(`Plane ${plane} cleared`, 'success');
      }
      
      static optimizeStorage() {
        // Rebalance transactions between planes based on current strategy
        const allTransactions = state.getAllTransactions();
        const targetPlane1Count = Math.floor(allTransactions.length / 2);
        const targetPlane2Count = allTransactions.length - targetPlane1Count;
        
        // Clear both planes
        this.clearPlane(1);
        this.clearPlane(2);
        
        // Reallocate transactions
        allTransactions.forEach((tx, index) => {
          const targetPlane = index < targetPlane1Count ? 1 : 2;
          this.addTransactionToPlane(tx, targetPlane);
        });
        
        NotificationManager.show('Storage optimized successfully', 'success');
      }
      
      static updateStorageUI() {
        // Update storage bars and stats
        this.updateStorageBar('storageBar1', state.storage.plane1.used, state.storage.plane1.capacity);
        this.updateStorageBar('storageBar2', state.storage.plane2.used, state.storage.plane2.capacity);
        this.updateStorageBar('storageBarTotal', state.getTotalStorageUsage(), state.storage.totalCapacity);
        
        // Update panel storage bars
        this.updateStorageBar('panelStorageBar1', state.storage.plane1.used, state.storage.plane1.capacity);
        this.updateStorageBar('panelStorageBar2', state.storage.plane2.used, state.storage.plane2.capacity);
        this.updateStorageBar('panelStorageBarTotal', state.getTotalStorageUsage(), state.storage.totalCapacity);
        
        // Update text displays
        this.updateStorageText('storageUsed1', state.storage.plane1.used);
        this.updateStorageText('storageUsed2', state.storage.plane2.used);
        this.updateStorageText('storageUsedTotal', state.getTotalStorageUsage());
        
        this.updateStorageText('panelStorageUsed1', state.storage.plane1.used);
        this.updateStorageText('panelStorageUsed2', state.storage.plane2.used);
        this.updateStorageText('panelStorageUsedTotal', state.getTotalStorageUsage());
        
        // Update transaction count
        TransactionManager.updateDisplay();
      }
      
      static updateStorageBar(barId, used, capacity) {
        const bar = document.getElementById(barId);
        if (!bar) return;
        
        const percentage = (used / capacity) * 100;
        bar.style.width = `${percentage}%`;
        
        // Update color based on usage
        bar.className = 'storage-fill';
        if (percentage < 50) {
          bar.classList.add('low');
        } else if (percentage < 80) {
          bar.classList.add('medium');
        } else {
          bar.classList.add('high');
        }
      }
      
      static updateStorageText(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
          element.textContent = value.toLocaleString();
        }
      }
      
      static setAllocationStrategy(strategy) {
        state.storage.allocationStrategy = strategy;
        
        // Update UI
        document.querySelectorAll('.allocation-option').forEach(option => {
          option.classList.remove('active');
        });
        
        const activeOption = document.querySelector(`[data-strategy="${strategy}"]`);
        if (activeOption) {
          activeOption.classList.add('active');
        }
        
        // Update panel display
        const panelStrategy = document.getElementById('panelAllocationStrategy');
        if (panelStrategy) {
          const strategyNames = {
            balanced: 'Balanced',
            priority: 'Priority',
            efficiency: 'Efficiency'
          };
          panelStrategy.textContent = strategyNames[strategy] || strategy;
        }
        
        NotificationManager.show(`Allocation strategy set to ${strategy}`, 'success');
      }
    }
    
    // ======================
    // Commodity Manager
    // ======================
    class CommodityManager {
      static fiatToCommodity(amount, commodityType) {
        const commodity = state.commodities[commodityType];
        if (!commodity) return 0;
        
        const tokenValue = amount / commodity.pricePerOunce;
        
        if (tokenValue > commodity.totalReserve - commodity.tokensInCirculation) {
          return 0; // Not enough reserve
        }
        
        return tokenValue;
      }
      
      static commodityToFiat(tokenAmount, commodityType) {
        const commodity = state.commodities[commodityType];
        if (!commodity) return 0;
        
        return tokenAmount * commodity.pricePerOunce;
      }
      
      static updatePrices() {
        state.commodities.gold.pricePerOunce *= (0.99 + Math.random() * 0.02);
        state.commodities.silver.pricePerOunce *= (0.99 + Math.random() * 0.02);
        
        this.updateCommodityUI();
      }
      
      static updateCommodityUI() {
        const goldPriceEl = document.getElementById('goldPrice');
        const silverPriceEl = document.getElementById('silverPrice');
        
        if (goldPriceEl) {
          goldPriceEl.textContent = `Gold: ${Utils.formatCurrency(state.commodities.gold.pricePerOunce)}/oz`;
        }
        
        if (silverPriceEl) {
          silverPriceEl.textContent = `Silver: ${Utils.formatCurrency(state.commodities.silver.pricePerOunce)}/oz`;
        }
      }
      
      static buyCommodityTokens(amount, commodityType) {
        if (!state.ui.isAuthenticated) return false;
        
        const tokenAmount = this.fiatToCommodity(amount, commodityType);
        if (tokenAmount <= 0) {
          NotificationManager.show('Insufficient reserve for this purchase!', 'error');
          return false;
        }
        
        if (state.userWallet.balance < amount) {
          NotificationManager.show('Insufficient fiat balance!', 'error');
          return false;
        }
        
        state.userWallet.balance -= amount;
        state.userWallet.commodityBalances[commodityType] += tokenAmount;
        
        state.commodities[commodityType].tokensInCirculation += tokenAmount;
        
        const txData = {
          id: Utils.generateId('BUY'),
          from: 'SYSTEM',
          to: state.userWallet.id,
          amount: tokenAmount,
          asset: commodityType,
          fiatValue: amount,
          description: `Purchased ${tokenAmount.toFixed(4)} ${commodityType} tokens`,
          timestamp: new Date().toISOString(),
          type: 'commodity_purchase',
          status: 'completed'
        };
        
        TransactionManager.addTransaction(txData);
        WalletManager.updateUI();
        NotificationManager.show(`Purchased ${tokenAmount.toFixed(4)} ${commodityType} tokens!`, 'success');
        
        return true;
      }
      
      static sellCommodityTokens(tokenAmount, commodityType) {
        if (!state.ui.isAuthenticated) return false;
        
        if (state.userWallet.commodityBalances[commodityType] < tokenAmount) {
          NotificationManager.show('Insufficient commodity tokens!', 'error');
          return false;
        }
        
        const fiatValue = this.commodityToFiat(tokenAmount, commodityType);
        
        state.userWallet.balance += fiatValue;
        state.userWallet.commodityBalances[commodityType] -= tokenAmount;
        
        state.commodities[commodityType].tokensInCirculation -= tokenAmount;
        
        const txData = {
          id: Utils.generateId('SELL'),
          from: state.userWallet.id,
          to: 'SYSTEM',
          amount: tokenAmount,
          asset: commodityType,
          fiatValue: fiatValue,
          description: `Sold ${tokenAmount.toFixed(4)} ${commodityType} tokens`,
          timestamp: new Date().toISOString(),
          type: 'commodity_sale',
          status: 'completed'
        };
        
        TransactionManager.addTransaction(txData);
        WalletManager.updateUI();
        NotificationManager.show(`Sold ${tokenAmount.toFixed(4)} ${commodityType} tokens for ${Utils.formatCurrency(fiatValue)}!`, 'success');
        
        return true;
      }
    }
    
    // ======================
    // Enhanced Performance Monitoring
    // ======================
    
    class PerformanceMonitor {
      constructor() {
        this.frameStart = 0;
        this.frameEnd = 0;
        this.fpsHistory = [];
        this.renderTimeHistory = [];
      }
      
      startFrame() {
        this.frameStart = performance.now();
      }
      
      endFrame() {
        this.frameEnd = performance.now();
        const renderTime = this.frameEnd - this.frameStart;
        
        // Update FPS
        state.performance.frameCount++;
        const now = Date.now();
        if (now - state.performance.lastFpsUpdate >= 1000) {
          state.performance.fps = state.performance.frameCount;
          state.performance.frameCount = 0;
          state.performance.lastFpsUpdate = now;
          this.updateFPSDisplay();
        }
        
        // Track render time
        this.renderTimeHistory.push(renderTime);
        if (this.renderTimeHistory.length > 60) {
          this.renderTimeHistory.shift();
        }
        
        state.performance.renderTime = renderTime;
      }
      
      updateFPSDisplay() {
        const fpsElement = document.getElementById('fpsCounter');
        const blockElement = document.getElementById('blockCounter');
        
        if (fpsElement) {
          fpsElement.textContent = state.performance.fps;
          fpsElement.style.color = state.performance.fps > 50 ? 'var(--success-color)' : 
                                   state.performance.fps > 30 ? 'var(--warning-color)' : 'var(--error-color)';
        }
        
        if (blockElement) {
          const currentPlaneData = state.getCurrentPlaneData();
          blockElement.textContent = currentPlaneData.blocks.length.toLocaleString();
        }
      }
      
      getAverageRenderTime() {
        if (this.renderTimeHistory.length === 0) return 0;
        return this.renderTimeHistory.reduce((a, b) => a + b, 0) / this.renderTimeHistory.length;
      }
    }
    
    const perfMonitor = new PerformanceMonitor();
    
    // ======================
    // Enhanced DOM Management
    // ======================
    const DOM = {
      // Authentication
      pinModal: document.getElementById('pinModal'),
      pinInput: document.getElementById('pinInput'),
      pinSubmit: document.getElementById('pinSubmit'),
      pinMessage: document.getElementById('pinMessage'),
      // Shutdown
      shutdownModal: document.getElementById('shutdownModal'),
      shutdownButton: document.getElementById('shutdownButton'),
      cancelShutdown: document.getElementById('cancelShutdown'),
      confirmShutdown: document.getElementById('confirmShutdown'),
      // Modals
      txModal: document.getElementById('txModal'),
      paymentModal: document.getElementById('paymentModal'),
      qrcodeModal: document.getElementById('qrcodeModal'),
      scanModal: document.getElementById('scanModal'),
      analyticsModal: document.getElementById('analyticsModal'),
      storageModal: document.getElementById('storageModal'),
      // Canvas and main UI
      canvas: document.getElementById('canvas'),
      ctx: document.getElementById('canvas')?.getContext('2d'),
      // Controls
      controls: document.getElementById('controls'),
      searchBox: document.getElementById('searchBox'),
      filterSelect: document.getElementById('filterSelect'),
      zoomSlider: document.getElementById('zoomSlider'),
      zoomDisplay: document.getElementById('zoomDisplay'),
      countDisplay: document.getElementById('countDisplay'),
      // Panels
      detailsPanel: document.getElementById('detailsPanel'),
      walletPanel: document.getElementById('walletPanel'),
      analyticsPanel: document.getElementById('analyticsPanel'),
      storagePanel: document.getElementById('storagePanel'),
      commodityPanel: document.getElementById('commodityPanel'),
      // Commodity
      goldPrice: document.getElementById('goldPrice'),
      silverPrice: document.getElementById('silverPrice'),
      goldBalance: document.getElementById('goldBalance'),
      silverBalance: document.getElementById('silverBalance'),
      // Notification
      notification: document.getElementById('notification'),
      // Theme
      themeToggle: document.getElementById('themeToggle'),
      // Plane Toggle
      planeToggle: document.getElementById('planeToggle'),
      planeLabel: document.getElementById('planeLabel'),
      // Zoom info
      zoomInfo: document.getElementById('zoomInfo'),
      // Storage management
      storageButton: document.getElementById('storageButton'),
      closeStorageModal: document.getElementById('closeStorageModal'),
      optimizeStorage: document.getElementById('optimizeStorage'),
      clearPlane1: document.getElementById('clearPlane1'),
      clearPlane2: document.getElementById('clearPlane2')
    };
    
    // ======================
    // Enhanced Utility Functions
    // ======================
    class Utils {
      static formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD'
        }).format(amount);
      }
      
      static formatDate(dateString) {
        return new Intl.DateTimeFormat('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        }).format(new Date(dateString));
      }
      
      static generateId(prefix = 'TXN') {
        return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      }
      
      static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      static throttle(func, limit) {
        let inThrottle;
        return function() {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
      
      static lerp(start, end, factor) {
        return start + (end - start) * factor;
      }
      
      static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
    }
    
    // ======================
    // Enhanced Authentication System
    // ======================
    class AuthenticationManager {
      constructor() {
        this.maxAttempts = 3;
        this.attempts = 0;
        this.lockoutTime = 5 * 60 * 1000; // 5 minutes
      }
      
      async checkPin() {
        const savedPin = localStorage.getItem('ledgerPin');
        const lockout = localStorage.getItem('ledgerLockout');
        
        // Check if locked out
        if (lockout && Date.now() < parseInt(lockout)) {
          const remainingTime = Math.ceil((parseInt(lockout) - Date.now()) / 1000 / 60);
          DOM.pinMessage.textContent = `Account locked. Try again in ${remainingTime} minutes.`;
          DOM.pinSubmit.disabled = true;
          return;
        }
        
        if (savedPin) {
          DOM.pinMessage.textContent = 'Enter your PIN to access the ledger';
          DOM.pinSubmit.textContent = 'Access Ledger';
        } else {
          DOM.pinMessage.textContent = 'Set a 4-digit PIN to secure your ledger';
          DOM.pinSubmit.textContent = 'Set PIN';
        }
        
        DOM.pinModal.style.display = 'flex';
        DOM.pinInput.focus();
      }
      
      async validatePin(pin) {
        if (pin.length !== 4 || !/^\d{4}$/.test(pin)) {
          this.showMessage('PIN must be exactly 4 digits');
          return false;
        }
        
        const savedPin = localStorage.getItem('ledgerPin');
        
        if (!savedPin) {
          // Set new PIN
          localStorage.setItem('ledgerPin', pin);
          this.showMessage('PIN set successfully!', 'success');
          state.ui.isAuthenticated = true;
          this.closeModal();
          await this.initializeApplication();
          return true;
        } else if (pin === savedPin) {
          // Correct PIN
          this.showMessage('Access granted!', 'success');
          state.ui.isAuthenticated = true;
          this.attempts = 0;
          localStorage.removeItem('ledgerLockout');
          this.closeModal();
          await this.initializeApplication();
          return true;
        } else {
          // Incorrect PIN
          this.attempts++;
          if (this.attempts >= this.maxAttempts) {
            localStorage.setItem('ledgerLockout', (Date.now() + this.lockoutTime).toString());
            this.showMessage('Too many failed attempts. Account locked for 5 minutes.', 'error');
            DOM.pinSubmit.disabled = true;
          } else {
            this.showMessage(`Incorrect PIN. ${this.maxAttempts - this.attempts} attempts remaining.`, 'error');
          }
          DOM.pinInput.value = '';
          return false;
        }
      }
      
      showMessage(message, type = 'warning') {
        DOM.pinMessage.textContent = message;
        DOM.pinMessage.style.color = `var(--${type}-color)`;
      }
      
      closeModal() {
        DOM.pinModal.style.display = 'none';
        DOM.pinInput.value = '';
        DOM.pinMessage.textContent = '';
      }
      
      async initializeApplication() {
        try {
          await CanvasManager.resizeCanvas();
          RenderEngine.updateZoomInfo();
          await WalletManager.initialize();
          await AnalyticsManager.initialize();
          
          // Initialize storage UI
          StorageManager.updateStorageUI();
          
          // Show welcome message
          NotificationManager.show('Welcome to Enhanced Blockchain Ledger with Dual Plane Storage!', 'success');
          
          // Auto-generate demo data
          setTimeout(() => {
            TransactionManager.generateGalaxy(250);
          }, 1000);
        } catch (error) {
          console.error('Error initializing application:', error);
          NotificationManager.show('Error initializing application. Please refresh.', 'error');
        }
      }
    }
    
    const authManager = new AuthenticationManager();
    
    // ======================
    // Enhanced Canvas Management
    // ======================
    class CanvasManager {
      static async resizeCanvas() {
        if (!state.ui.isAuthenticated) return;
        
        const controlsHeight = DOM.controls?.offsetHeight || 0;
        DOM.canvas.width = window.innerWidth;
        DOM.canvas.height = window.innerHeight - controlsHeight;
        DOM.canvas.style.marginTop = `${controlsHeight}px`;
        
        // Enable high DPI rendering
        const devicePixelRatio = window.devicePixelRatio || 1;
        const rect = DOM.canvas.getBoundingClientRect();
        
        DOM.canvas.width = rect.width * devicePixelRatio;
        DOM.canvas.height = rect.height * devicePixelRatio;
        DOM.canvas.style.width = rect.width + 'px';
        DOM.canvas.style.height = rect.height + 'px';
        
        DOM.ctx.scale(devicePixelRatio, devicePixelRatio);
        
        this.centerView();
        RenderEngine.requestDraw();
      }
      
      static centerView() {
        if (!state.ui.isAuthenticated) return;
        
        const currentPlaneData = state.getCurrentPlaneData();
        if (currentPlaneData.blocks.length === 0) return;
        
        const blockSize = 40 * state.ui.zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        const cols = Math.max(1, Math.floor(DOM.canvas.width / (hexWidth * 0.75)));
        const rows = Math.ceil(currentPlaneData.blocks.length / cols);
        const layoutWidth = cols * hexWidth * 0.75;
        const layoutHeight = rows * hexHeight;
        
        state.ui.dragOffset.x = (DOM.canvas.width - layoutWidth) / 2;
        state.ui.dragOffset.y = (DOM.canvas.height - layoutHeight) / 2;
      }
    }
    
    // ======================
    // Enhanced Render Engine
    // ======================
    class RenderEngine {
      static PIXEL_THRESHOLD = 0.3;
      static SIMPLE_THRESHOLD = 0.8;
      static colors = {
        source: '#3498db',
        dest: '#2ecc71',
        payment: '#16a085',
        qrcode: '#2c3e50',
        connection: '#e74c3c',
        highlight: '#f1c40f',
        // Colors for the second plane
        plane2_source: '#9b59b6',
        plane2_dest: '#1abc9c',
        plane2_connection: '#e67e22'
      };
      
      static requestDraw() {
        state.ui.needsRedraw = true;
      }
      
      static animate() {
        if (state.ui.needsRedraw) {
          perfMonitor.startFrame();
          this.draw();
          state.ui.needsRedraw = false;
          perfMonitor.endFrame();
        }
        state.ui.animationFrameId = requestAnimationFrame(() => this.animate());
      }
      
      static draw() {
        if (!state.ui.isAuthenticated || !DOM.ctx) return;
        
        DOM.ctx.clearRect(0, 0, DOM.canvas.width, DOM.canvas.height);
        
        const currentPlaneData = state.getCurrentPlaneData();
        if (currentPlaneData.blocks.length === 0) {
          this.drawEmptyState();
          return;
        }
        
        // Apply theme
        this.applyTheme();
        
        if (state.ui.zoom < this.PIXEL_THRESHOLD) {
          this.drawGalaxyView();
        } else if (state.ui.zoom < this.SIMPLE_THRESHOLD) {
          this.drawClusterView();
        } else {
          this.drawBlockView();
        }
        
        // Draw overlay effects
        this.drawOverlayEffects();
      }
      
      static applyTheme() {
        if (!state.ui.darkTheme) {
          // Light theme adjustments
          this.colors.source = '#2980b9';
          this.colors.dest = '#27ae60';
          this.colors.payment = '#138d75';
          this.colors.plane2_source = '#8e44ad';
          this.colors.plane2_dest = '#16a085';
          DOM.ctx.globalCompositeOperation = 'source-over';
        } else {
          // Dark theme (default)
          this.colors.source = '#3498db';
          this.colors.dest = '#2ecc71';
          this.colors.payment = '#16a085';
          this.colors.plane2_source = '#9b59b6';
          this.colors.plane2_dest = '#1abc9c';
        }
      }
      
      static drawEmptyState() {
        DOM.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        DOM.ctx.font = '24px Inter, sans-serif';
        DOM.ctx.textAlign = 'center';
        DOM.ctx.textBaseline = 'middle';
        
        const currentPlaneData = state.getCurrentPlaneData();
        const storage = currentPlaneData.storage;
        
        DOM.ctx.fillText(
          `No transactions in Plane ${state.ui.currentPlane}. Storage: ${storage.used.toLocaleString()}/${storage.capacity.toLocaleString()}`,
          DOM.canvas.width / 2,
          DOM.canvas.height / 2
        );
      }
      
      static drawGalaxyView() {
        const currentPlaneData = state.getCurrentPlaneData();
        const cols = Math.max(1, Math.floor(DOM.canvas.width / 3));
        const spacing = 3;
        
        DOM.ctx.imageSmoothingEnabled = false;
        
        // Optimized viewport culling
        const viewportBuffer = 50;
        const startIdx = Math.max(0, Math.floor((-state.ui.dragOffset.y - viewportBuffer) / spacing) * cols);
        const endIdx = Math.min(currentPlaneData.blocks.length, 
          Math.ceil((DOM.canvas.height - state.ui.dragOffset.y + viewportBuffer) / spacing) * cols);
        
        // Batch render pixels for better performance
        const imageData = DOM.ctx.createImageData(DOM.canvas.width, DOM.canvas.height);
        const data = imageData.data;
        
        for (let index = startIdx; index < endIdx; index++) {
          const block = currentPlaneData.blocks[index];
          if (!this.passesFilter(block)) continue;
          
          const col = index % cols;
          const row = Math.floor(index / cols);
          const x = Math.floor(col * spacing + state.ui.dragOffset.x + DOM.canvas.width / 4);
          const y = Math.floor(row * spacing + state.ui.dragOffset.y + DOM.canvas.height / 4);
          
          if (x < 0 || x >= DOM.canvas.width || y < 0 || y >= DOM.canvas.height) continue;
          
          const isSearched = this.isSearchMatch(block);
          const alpha = (state.ui.searchQuery && !isSearched) ? 25 : 255;
          
          const pixelIndex = (y * DOM.canvas.width + x) * 4;
          const color = this.getBlockColor(block);
          const rgb = this.hexToRgb(color);
          
          data[pixelIndex] = rgb.r;     // Red
          data[pixelIndex + 1] = rgb.g; // Green
          data[pixelIndex + 2] = rgb.b; // Blue
          data[pixelIndex + 3] = alpha; // Alpha
        }
        
        DOM.ctx.putImageData(imageData, 0, 0);
        DOM.ctx.imageSmoothingEnabled = true;
      }
      
      static drawClusterView() {
        const currentPlaneData = state.getCurrentPlaneData();
        const blockSize = 25 * state.ui.zoom;
        const hexWidth = blockSize * 1.8;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Draw connections with improved styling
        this.drawConnections(hexWidth, hexHeight, 1.5 * state.ui.zoom);
        
        // Draw simplified hexagons with better performance
        const visibleBlocks = this.getVisibleBlocks(hexWidth, hexHeight);
        
        for (const { block, index, pos } of visibleBlocks) {
          if (!this.passesFilter(block)) continue;
          
          const isSearched = this.isSearchMatch(block);
          DOM.ctx.globalAlpha = (state.ui.searchQuery && !isSearched) ? 0.3 : 1.0;
          
          this.drawSimpleHexagon(pos.x, pos.y, blockSize, this.getBlockColor(block));
        }
        
        DOM.ctx.globalAlpha = 1.0;
      }
      
      static drawBlockView() {
        const currentPlaneData = state.getCurrentPlaneData();
        const blockSize = 40 * state.ui.zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Draw enhanced connections
        this.drawConnections(hexWidth, hexHeight, 3 * state.ui.zoom);
        
        // Draw detailed blocks
        const visibleBlocks = this.getVisibleBlocks(hexWidth, hexHeight);
        
        for (const { block, index, pos } of visibleBlocks) {
          if (!this.passesFilter(block)) continue;
          this.drawDetailedHexBlock(block, pos.x, pos.y, index, blockSize);
        }
      }
      
      static drawConnections(hexWidth, hexHeight, lineWidth) {
        const currentPlaneData = state.getCurrentPlaneData();
        const connectionColor = state.ui.currentPlane === 1 ? 
          this.colors.connection : this.colors.plane2_connection;
        
        DOM.ctx.strokeStyle = connectionColor;
        DOM.ctx.lineWidth = lineWidth;
        DOM.ctx.lineCap = 'round';
        
        // Get transactions for current plane only
        const planeTransactions = state.ui.currentPlane === 1 ? state.transactions1 : state.transactions2;
        
        for (let i = 0; i < planeTransactions.length; i++) {
          const tx = planeTransactions[i];
          const sourceIndex = currentPlaneData.blocks.findIndex(b => b.txId === tx.id && b.type === 'source');
          const destIndex = currentPlaneData.blocks.findIndex(b => b.txId === tx.id && b.type === 'destination');
          
          if (sourceIndex === -1 || destIndex === -1) continue;
          
          const posA = this.getBlockPosition(sourceIndex, hexWidth, hexHeight);
          const posB = this.getBlockPosition(destIndex, hexWidth, hexHeight);
          
          // Viewport culling for connections
          if (!this.isConnectionVisible(posA, posB)) continue;
          
          const isHovered = state.ui.hoveredBlockIndex !== -1 && 
            currentPlaneData.blocks[state.ui.hoveredBlockIndex].txId === tx.id;
          const isSelected = state.ui.selectedTxId === tx.id;
          const isSearched = this.isTransactionSearchMatch(tx);
          
          DOM.ctx.globalAlpha = (state.ui.searchQuery && !isSearched) ? 0.2 : 1.0;
          
          // Enhanced connection styling
          if (isHovered || isSelected) {
            DOM.ctx.strokeStyle = this.colors.highlight;
            DOM.ctx.lineWidth = lineWidth * 1.5;
            DOM.ctx.shadowColor = this.colors.highlight;
            DOM.ctx.shadowBlur = 10;
          } else if (tx.type === 'payment') {
            DOM.ctx.strokeStyle = tx.paymentType === 'qrcode' ? this.colors.qrcode : this.colors.payment;
          } else {
            DOM.ctx.strokeStyle = connectionColor;
          }
          
          DOM.ctx.beginPath();
          DOM.ctx.moveTo(posA.x, posA.y);
          DOM.ctx.lineTo(posB.x, posB.y);
          DOM.ctx.stroke();
          
          // Reset effects
          DOM.ctx.shadowBlur = 0;
          DOM.ctx.strokeStyle = connectionColor;
          DOM.ctx.lineWidth = lineWidth;
        }
        
        DOM.ctx.globalAlpha = 1.0;
      }
      
      static drawDetailedHexBlock(block, x, y, index, blockSize) {
        const currentPlaneData = state.getCurrentPlaneData();
        const isHovered = state.ui.hoveredBlockIndex !== -1 && 
          currentPlaneData.blocks[state.ui.hoveredBlockIndex].txId === block.txId;
        const isSelected = state.ui.selectedTxId === block.txId;
        const isSearched = this.isSearchMatch(block);
        
        DOM.ctx.save();
        DOM.ctx.globalAlpha = (state.ui.searchQuery && !isSearched) ? 0.2 : 1.0;
        
        // Enhanced visual effects
        if (isHovered || isSelected) {
          DOM.ctx.fillStyle = this.colors.highlight;
          DOM.ctx.shadowColor = this.colors.highlight;
          DOM.ctx.shadowBlur = 15;
        } else {
          DOM.ctx.fillStyle = this.getBlockColor(block);
          if (state.ui.historyMode) {
            DOM.ctx.shadowColor = '#9b59b6';
            DOM.ctx.shadowBlur = 8;
          }
        }
        
        // Draw hexagon with improved geometry
        this.drawHexagon(x, y, blockSize);
        DOM.ctx.fill();
        
        if (isSelected) {
          DOM.ctx.strokeStyle = 'white';
          DOM.ctx.lineWidth = 4;
          DOM.ctx.stroke();
        }
        
        // Draw enhanced text labels
        if (state.ui.zoom > 0.6) {
          this.drawBlockText(block, x, y, blockSize, isHovered || isSelected);
        }
        
        DOM.ctx.restore();
      }
      
      static drawHexagon(x, y, size) {
        DOM.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i;
          const px = x + size * Math.cos(angle);
          const py = y + size * Math.sin(angle);
          i === 0 ? DOM.ctx.moveTo(px, py) : DOM.ctx.lineTo(px, py);
        }
        DOM.ctx.closePath();
      }
      
      static drawSimpleHexagon(x, y, size, color) {
        DOM.ctx.fillStyle = color;
        this.drawHexagon(x, y, size);
        DOM.ctx.fill();
      }
      
      static drawBlockText(block, x, y, blockSize, isHighlighted) {
        DOM.ctx.fillStyle = isHighlighted ? '#000' : '#fff';
        DOM.ctx.textAlign = 'center';
        DOM.ctx.textBaseline = 'middle';
        DOM.ctx.font = `bold ${Math.max(8, blockSize * 0.12)}px Inter, sans-serif`;
        
        let label = block.type === 'source' ? 'FROM' : 'TO';
        if (block.data.type === 'payment') {
          label = block.type === 'source' ? 'PAYER' : 'PAYEE';
          if (block.data.paymentType === 'qrcode') {
            label = '📱 ' + label;
          }
        }
        
        // Draw label
        DOM.ctx.fillText(label, x, y - blockSize * 0.3);
        
        // Draw identifier
        DOM.ctx.font = `${Math.max(7, blockSize * 0.1)}px Inter, sans-serif`;
        let displayText = block.type === 'source' ? block.data.from : block.data.to;
        if (displayText.length > 8) {
          displayText = displayText.substring(0, 8) + '…';
        }
        DOM.ctx.fillText(displayText, x, y);
        
        // Draw additional info for high zoom
        if (state.ui.zoom > 1.5) {
          DOM.ctx.fillText(`ID: ${block.data.id.slice(-4)}`, x, y + blockSize * 0.3);
        }
      }
      
      static drawOverlayEffects() {
        // Draw selection highlights, animations, etc.
        if (state.ui.hoveredBlockIndex !== -1) {
          const currentPlaneData = state.getCurrentPlaneData();
          const block = currentPlaneData.blocks[state.ui.hoveredBlockIndex];
          // Additional hover effects can be implemented here
        }
      }
      
      // Utility methods
      static getVisibleBlocks(hexWidth, hexHeight) {
        const currentPlaneData = state.getCurrentPlaneData();
        const visible = [];
        const buffer = 100;
        
        for (let i = 0; i < currentPlaneData.blocks.length; i++) {
          const pos = this.getBlockPosition(i, hexWidth, hexHeight);
          if (pos.x > -buffer && pos.x < DOM.canvas.width + buffer &&
              pos.y > -buffer && pos.y < DOM.canvas.height + buffer) {
            visible.push({ block: currentPlaneData.blocks[i], index: i, pos });
          }
        }
        
        return visible;
      }
      
      static getBlockPosition(index, hexWidth, hexHeight) {
        const currentPlaneData = state.getCurrentPlaneData();
        const cols = Math.max(1, Math.floor(DOM.canvas.width / (hexWidth * 0.75)));
        const col = index % cols;
        const row = Math.floor(index / cols);
        
        const layoutWidth = cols * hexWidth * 0.75;
        const layoutHeight = Math.ceil(currentPlaneData.blocks.length / cols) * hexHeight;
        const centerOffsetX = DOM.canvas.width / 2 - layoutWidth / 2;
        const centerOffsetY = DOM.canvas.height / 2 - layoutHeight / 2;
        
        const x = col * hexWidth * 0.75 + state.ui.dragOffset.x + centerOffsetX;
        const y = row * hexHeight + (col % 2 === 0 ? 0 : hexHeight / 2) + state.ui.dragOffset.y + centerOffsetY;
        return { x, y };
      }
      
      static isConnectionVisible(posA, posB) {
        const buffer = 50;
        return !((posA.x < -buffer && posB.x < -buffer) || 
                (posA.x > DOM.canvas.width + buffer && posB.x > DOM.canvas.width + buffer) ||
                (posA.y < -buffer && posB.y < -buffer) || 
                (posA.y > DOM.canvas.height + buffer && posB.y > DOM.canvas.height + buffer));
      }
      
      static passesFilter(block) {
        if (state.ui.filterType === 'all') return true;
        if (state.ui.filterType === 'payment' && block.data.type !== 'payment') return false;
        if (state.ui.filterType === 'qrcode' && block.data.paymentType !== 'qrcode') return false;
        if (state.ui.filterType !== 'payment' && state.ui.filterType !== 'qrcode' && block.type !== state.ui.filterType) return false;
        return true;
      }
      
      static isSearchMatch(block) {
        if (!state.ui.searchQuery) return true;
        const query = state.ui.searchQuery.toLowerCase();
        return block.data.id.toLowerCase().includes(query) ||
               block.data.from.toLowerCase().includes(query) ||
               block.data.to.toLowerCase().includes(query) ||
               block.data.description?.toLowerCase().includes(query);
      }
      
      static isTransactionSearchMatch(tx) {
        if (!state.ui.searchQuery) return true;
        const query = state.ui.searchQuery.toLowerCase();
        return tx.id.toLowerCase().includes(query) ||
               tx.from.toLowerCase().includes(query) ||
               tx.to.toLowerCase().includes(query) ||
               tx.description?.toLowerCase().includes(query);
      }
      
      static getBlockColor(block) {
        if (block.data.type === 'payment') {
          return block.data.paymentType === 'qrcode' ? this.colors.qrcode : this.colors.payment;
        }
        
        // Use different colors based on the current plane
        if (state.ui.currentPlane === 1) {
          return block.type === 'source' ? this.colors.source : this.colors.dest;
        } else {
          return block.type === 'source' ? this.colors.plane2_source : this.colors.plane2_dest;
        }
      }
      
      static hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 255, g: 255, b: 255 };
      }
      
      static updateZoomInfo() {
        const info = DOM.zoomInfo;
        if (!info) return;
        
        const currentPlaneData = state.getCurrentPlaneData();
        const storage = currentPlaneData.storage;
        
        if (state.ui.zoom < this.PIXEL_THRESHOLD) {
          info.innerHTML = `<strong>🌌 Galaxy View - Plane ${state.ui.currentPlane}</strong><br>Storage: ${storage.used.toLocaleString()}/${storage.capacity.toLocaleString()} transactions`;
        } else if (state.ui.zoom < this.SIMPLE_THRESHOLD) {
          info.innerHTML = `<strong>🔍 Cluster View - Plane ${state.ui.currentPlane}</strong><br>Storage: ${storage.used.toLocaleString()}/${storage.capacity.toLocaleString()} transactions`;
        } else {
          info.innerHTML = `<strong>📋 Detail View - Plane ${state.ui.currentPlane}</strong><br>Storage: ${storage.used.toLocaleString()}/${storage.capacity.toLocaleString()} transactions`;
        }
      }
    }
    
    // ======================
    // Enhanced Transaction Management
    // ======================
    class TransactionManager {
      static generateGalaxy(count = 1000) {
        if (!state.ui.isAuthenticated) return;
        
        const names = [
          "Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Heidi", 
          "Ivan", "Judy", "Kevin", "Luna", "Mike", "Nina", "Oscar", "Penny",
          "Quinn", "Rachel", "Steve", "Tina", "Uma", "Victor", "Wendy", "Xander"
        ];
        
        const items = [
          "Smart Contract Execution", "DeFi Token Swap", "NFT Marketplace Trade",
          "Cross-chain Bridge", "Governance Voting", "Staking Rewards", "Liquidity Mining",
          "Oracle Data Feed", "Layer 2 Settlement", "Privacy Transaction", "DAO Proposal",
          "Yield Farming", "Flash Loan", "Arbitrage Trade", "Insurance Claim"
        ];
        
        NotificationManager.show(`Generating ${count.toLocaleString()} transactions...`, 'default');
        
        const batchSize = 500;
        let processed = 0;
        
        const processBatch = () => {
          try {
            const end = Math.min(processed + batchSize, count);
            
            for (let i = processed; i < end; i++) {
              const from = names[Math.floor(Math.random() * names.length)];
              let to;
              do { to = names[Math.floor(Math.random() * names.length)]; } while (from === to);
              
              const isCommodity = Math.random() > 0.9;
              const commodityType = isCommodity ? (Math.random() > 0.5 ? 'gold' : 'silver') : null;
              const amount = isCommodity ? 
                (Math.random() * 10).toFixed(4) : // Smaller amounts for commodities
                (Math.random() * 5000 + 10).toFixed(2);
              const description = items[Math.floor(Math.random() * items.length)];
              const timestamp = new Date(Date.now() - (count - i) * 30000).toISOString();
              
              const isPayment = Math.random() > 0.8;
              const isQRPayment = isPayment && Math.random() > 0.7;
              
              const newTx = {
                id: Utils.generateId(isPayment ? (isQRPayment ? 'QRP' : 'PAY') : isCommodity ? 'COM' : 'TXN'),
                from, to, 
                amount,
                asset: isCommodity ? commodityType : 'fiat',
                fiatValue: isCommodity ? CommodityManager.commodityToFiat(parseFloat(amount), commodityType) : amount,
                description, 
                timestamp,
                type: isPayment ? 'payment' : isCommodity ? 'commodity_transfer' : 'standard',
                paymentType: isQRPayment ? 'qrcode' : 'standard',
                status: 'completed'
              };
              
              // Add transaction using storage manager
              try {
                const plane = StorageManager.allocateTransaction(newTx);
                StorageManager.addTransactionToPlane(newTx, plane);
              } catch (error) {
                console.warn('Could not add transaction:', error.message);
                // Stop generation if both planes are full
                break;
              }
            }
            
            processed = end;
            this.updateDisplay();
            AnalyticsManager.updateRealTimeStats();
            
            if (processed < count) {
              requestIdleCallback(processBatch);
            } else {
              NotificationManager.show(`Galaxy generated with ${processed.toLocaleString()} transactions!`, 'success');
              CanvasManager.centerView();
            }
          } catch (error) {
            console.error('Error generating galaxy:', error);
            NotificationManager.show('Error generating transactions. Please try again.', 'error');
          }
        };
        
        processBatch();
      }
      
      static addTransaction(txData = null, targetPlane = 'auto') {
        if (!state.ui.isAuthenticated) return;
        
        const newTx = txData || {
          id: Utils.generateId(),
          from: "User_" + Math.floor(Math.random() * 1000),
          to: "User_" + Math.floor(Math.random() * 1000),
          amount: (Math.random() * 500 + 10).toFixed(2),
          asset: 'fiat',
          description: "Manual Transaction",
          timestamp: new Date().toISOString(),
          type: 'standard',
          status: 'completed'
        };
        
        try {
          const plane = StorageManager.allocateTransaction(newTx, targetPlane);
          StorageManager.addTransactionToPlane(newTx, plane);
          
          this.updateDisplay();
          AnalyticsManager.updateRealTimeStats();
          
          NotificationManager.show(`Transaction added to Plane ${plane}`, 'success');
          return true;
        } catch (error) {
          NotificationManager.show(error.message, 'error');
          return false;
        }
      }
      
      static updateDisplay() {
        if (DOM.countDisplay) {
          const currentPlaneData = state.getCurrentPlaneData();
          DOM.countDisplay.textContent = `Transactions: ${currentPlaneData.transactions.length.toLocaleString()}`;
        }
        RenderEngine.requestDraw();
      }
      
      static clearLedger() {
        if (!state.ui.isAuthenticated) return;
        
        state.transactions1 = [];
        state.transactions2 = [];
        state.blocks1 = [];
        state.blocks2 = [];
        state.storage.plane1.used = 0;
        state.storage.plane1.transactions = [];
        state.storage.plane2.used = 0;
        state.storage.plane2.transactions = [];
        
        state.ui.dragOffset = { x: 0, y: 0 };
        state.ui.selectedTxId = null;
        state.analytics.totalVolume = 0;
        state.analytics.activeWallets.clear();
        
        UIManager.hidePanels();
        StorageManager.updateStorageUI();
        this.updateDisplay();
        AnalyticsManager.updateRealTimeStats();
      }
      
      static deleteTransaction(txId) {
        if (StorageManager.removeTransaction(txId)) {
          state.ui.selectedTxId = null;
          UIManager.hidePanel('details');
          this.updateDisplay();
          AnalyticsManager.updateRealTimeStats();
          NotificationManager.show('Transaction deleted from history!', 'warning');
        }
      }
      
      static forkTransaction(txId) {
        // Find the transaction
        let tx = null;
        for (let plane = 1; plane <= 2; plane++) {
          const transactions = plane === 1 ? state.transactions1 : state.transactions2;
          const foundTx = transactions.find(t => t.id === txId);
          if (foundTx) {
            tx = foundTx;
            break;
          }
        }
        
        if (tx) {
          const forkTx = {
            ...tx,
            id: tx.id + '-FORK-' + Date.now(),
            description: tx.description + ' (Timeline Fork)',
            timestamp: new Date().toISOString()
          };
          
          try {
            const plane = StorageManager.allocateTransaction(forkTx);
            StorageManager.addTransactionToPlane(forkTx, plane);
            NotificationManager.show('Timeline forked! Created alternate history branch.', 'success');
          } catch (error) {
            NotificationManager.show('Could not fork transaction: ' + error.message, 'error');
          }
        }
      }
    }
    
    // ======================
    // Enhanced Wallet Management
    // ======================
    class WalletManager {
      static async initialize() {
        try {
          const saved = localStorage.getItem('directLedgerWallet');
          if (saved) {
            state.userWallet = JSON.parse(saved);
            if (!state.userWallet.commodityBalances) {
              state.userWallet.commodityBalances = {
                gold: 0,
                silver: 0
              };
            }
          } else {
            state.userWallet = {
              id: this.generateWalletId(),
              balance: 500.00,
              transactions: [],
              commodityBalances: {
                gold: 0,
                silver: 0
              }
            };
            this.save();
          }
          this.updateUI();
        } catch (error) {
          console.error('Error initializing wallet:', error);
          NotificationManager.show('Error initializing wallet. Using default values.', 'warning');
        }
      }
      
      static generateWalletId() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = 'DL-';
        for (let i = 0; i < 12; i++) {
          if (i > 0 && i % 4 === 0) result += '-';
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }
      
      static save() {
        try {
          localStorage.setItem('directLedgerWallet', JSON.stringify(state.userWallet));
        } catch (error) {
          console.error('Error saving wallet:', error);
          NotificationManager.show('Error saving wallet data.', 'error');
        }
      }
      
      static updateUI() {
        const elements = {
          walletId: document.getElementById('walletId'),
          walletBalance: document.getElementById('walletBalance'),
          walletPanelBalance: document.getElementById('walletPanelBalance'),
          recentPayments: document.getElementById('recentPayments'),
          goldBalance: document.getElementById('goldBalance'),
          silverBalance: document.getElementById('silverBalance')
        };
        
        if (elements.walletId) elements.walletId.textContent = state.userWallet.id;
        if (elements.walletBalance) elements.walletBalance.textContent = Utils.formatCurrency(state.userWallet.balance);
        if (elements.walletPanelBalance) elements.walletPanelBalance.textContent = Utils.formatCurrency(state.userWallet.balance);
        
        if (elements.goldBalance) {
          const goldValue = CommodityManager.commodityToFiat(
            state.userWallet.commodityBalances.gold, 
            'gold'
          );
          elements.goldBalance.textContent = `${state.userWallet.commodityBalances.gold.toFixed(4)} Au (${Utils.formatCurrency(goldValue)})`;
        }
        
        if (elements.silverBalance) {
          const silverValue = CommodityManager.commodityToFiat(
            state.userWallet.commodityBalances.silver, 
            'silver'
          );
          elements.silverBalance.textContent = `${state.userWallet.commodityBalances.silver.toFixed(4)} Ag (${Utils.formatCurrency(silverValue)})`;
        }
        
        CommodityManager.updateCommodityUI();
        
        this.updateRecentPayments(elements.recentPayments);
      }
      
      static updateRecentPayments(container) {
        if (!container) return;
        
        if (state.userWallet.transactions.length === 0) {
          container.innerHTML = '<p style="opacity: 0.6; text-align: center; margin: 1rem;">No payments yet</p>';
          return;
        }
        
        container.innerHTML = '';
        const recent = state.userWallet.transactions.slice(-5).reverse();
        
        recent.forEach(tx => {
          if (!tx) return;
          
          const isOutgoing = tx.from === state.userWallet.id;
          const txEl = document.createElement('div');
          txEl.className = 'payment-item';
          txEl.style.cssText = `
            padding: 0.75rem;
            border-bottom: 1px solid var(--glass-border);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: var(--glass-bg);
            transition: all 0.2s ease;
            cursor: pointer;
          `;
          
          const amountText = tx.asset === 'fiat' 
            ? Utils.formatCurrency(parseFloat(tx.amount || 0))
            : `${parseFloat(tx.amount || 0).toFixed(4)} ${(tx.asset || 'unknown').toUpperCase()} (${Utils.formatCurrency(tx.fiatValue || 0)})`;
          
          txEl.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <div style="font-weight: 600; color: ${isOutgoing ? 'var(--error-color)' : 'var(--success-color)'};">
                  ${isOutgoing ? '→' : '←'} ${isOutgoing ? (tx.to || 'unknown').substring(0, 12) + '...' : (tx.from || 'unknown').substring(0, 12) + '...'}
                </div>
                <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 0.2rem;">
                  ${tx.timestamp ? Utils.formatDate(tx.timestamp) : 'Unknown date'}
                </div>
              </div>
              <div style="text-align: right;">
                <div style="font-weight: bold; font-size: 1.1rem; color: ${isOutgoing ? 'var(--error-color)' : 'var(--success-color)'};">
                  ${isOutgoing ? '-' : '+'}${amountText}
                </div>
                <div class="tx-status tx-status-${tx.status || 'unknown'}" style="margin-top: 0.2rem;">
                  ${tx.status || 'unknown'}
                </div>
              </div>
            </div>
          `;
          
          txEl.addEventListener('mouseenter', () => {
            txEl.style.background = 'var(--glass-strong)';
            txEl.style.transform = 'translateX(5px)';
          });
          
          txEl.addEventListener('mouseleave', () => {
            txEl.style.background = 'var(--glass-bg)';
            txEl.style.transform = 'translateX(0)';
          });
          
          container.appendChild(txEl);
        });
      }
      
      static processPayment(recipient, amount, note, speed, paymentType = 'standard') {
        const fees = { instant: 0.005, fast: 0.002, standard: 0 };
        const fee = amount * (fees[speed] || 0);
        const totalAmount = amount + fee;
        
        if (state.userWallet.balance < totalAmount) {
          NotificationManager.show('Insufficient balance for this payment!', 'error');
          return false;
        }
        
        const paymentTx = {
          id: Utils.generateId(paymentType === 'qrcode' ? 'QRP' : 'PAY'),
          from: state.userWallet.id,
          to: recipient,
          amount: amount,
          fee: fee,
          description: note || 'DirectLedger Payment',
          timestamp: new Date().toISOString(),
          speed: speed,
          type: 'payment',
          paymentType: paymentType,
          status: 'pending',
          asset: 'fiat'
        };
        
        state.userWallet.balance -= totalAmount;
        state.userWallet.transactions.push(paymentTx);
        
        try {
          const plane = StorageManager.allocateTransaction(paymentTx);
          StorageManager.addTransactionToPlane(paymentTx, plane);
        } catch (error) {
          NotificationManager.show('Payment failed: ' + error.message, 'error');
          return false;
        }
        
        const processingTime = speed === 'instant' ? 500 : speed === 'fast' ? 2000 : 5000;
        
        setTimeout(() => {
          paymentTx.status = 'completed';
          this.save();
          this.updateUI();
          NotificationManager.show(
            `${paymentType === 'qrcode' ? 'QR ' : ''}Payment of ${Utils.formatCurrency(amount)} sent successfully!`, 
            'payment-notification'
          );
        }, processingTime);
        
        this.save();
        this.updateUI();
        return true;
      }
      
      static addFunds(amount) {
        if (!amount || amount <= 0) return false;
        
        state.userWallet.balance += amount;
        state.userWallet.transactions.push({
          id: Utils.generateId('ADD'),
          from: 'SYSTEM',
          to: state.userWallet.id,
          amount: amount,
          description: 'Funds Added',
          timestamp: new Date().toISOString(),
          type: 'add_funds',
          status: 'completed',
          asset: 'fiat'
        });
        
        this.save();
        this.updateUI();
        NotificationManager.show(`Added ${Utils.formatCurrency(amount)} to your wallet!`, 'success');
        return true;
      }
    }
    
    // ======================
    // Enhanced Analytics Management
    // ======================
    class AnalyticsManager {
      static async initialize() {
        try {
          this.updateRealTimeStats();
          this.startRealTimeUpdates();
        } catch (error) {
          console.error('Error initializing analytics:', error);
          NotificationManager.show('Error initializing analytics.', 'warning');
        }
      }
      
      static updateRealTimeStats() {
        const elements = {
          txRate: document.getElementById('txRate'),
          totalVolume: document.getElementById('totalVolume'),
          activeWallets: document.getElementById('activeWallets'),
          networkStatus: document.getElementById('networkStatus'),
          networkHealth: document.getElementById('networkHealth')
        };
        
        // Calculate transaction rate (simplified)
        const allTransactions = state.getAllTransactions();
        const recentTx = allTransactions.filter(tx => {
          const age = Date.now() - new Date(tx.timestamp).getTime();
          return age < 60000; // Last minute
        });
        
        state.analytics.txRate = recentTx.length;
        
        // Update UI
        if (elements.txRate) elements.txRate.textContent = `${state.analytics.txRate} tx/min`;
        if (elements.totalVolume) elements.totalVolume.textContent = Utils.formatCurrency(state.analytics.totalVolume);
        if (elements.activeWallets) elements.activeWallets.textContent = state.analytics.activeWallets.size.toLocaleString();
        
        // Network health simulation
        const health = state.analytics.txRate > 50 ? 'congested' : state.analytics.txRate > 20 ? 'busy' : 'healthy';
        const healthColors = { healthy: 'var(--success-color)', busy: 'var(--warning-color)', congested: 'var(--error-color)' };
        
        if (elements.networkHealth) elements.networkHealth.style.background = healthColors[health];
        if (elements.networkStatus) elements.networkStatus.textContent = health.charAt(0).toUpperCase() + health.slice(1);
      }
      
      static startRealTimeUpdates() {
        setInterval(() => {
          this.updateRealTimeStats();
        }, 5000);
      }
      
      static showAnalyticsModal() {
        if (DOM.analyticsModal) {
          DOM.analyticsModal.style.display = 'flex';
          this.renderCharts();
        }
      }
      
      static renderCharts() {
        this.renderVolumeChart();
        this.renderTypeChart();
      }
      
      static renderVolumeChart() {
        const canvas = document.getElementById('volumeChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Simple volume chart visualization
        ctx.fillStyle = 'var(--payment-color)';
        ctx.fillRect(50, 150, 500, 30);
        
        ctx.fillStyle = 'white';
        ctx.font = '14px Inter';
        ctx.fillText('Transaction Volume Over Time', 10, 20);
        ctx.fillText(`Total: ${Utils.formatCurrency(state.analytics.totalVolume)}`, 10, 40);
      }
      
      static renderTypeChart() {
        const canvas = document.getElementById('typeChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Simple pie chart for transaction types
        const allTransactions = state.getAllTransactions();
        const types = {
          standard: allTransactions.filter(tx => tx.type === 'standard').length,
          payment: allTransactions.filter(tx => tx.type === 'payment' && tx.paymentType !== 'qrcode').length,
          qrcode: allTransactions.filter(tx => tx.paymentType === 'qrcode').length
        };
        
        const total = Object.values(types).reduce((a, b) => a + b, 0);
        let startAngle = 0;
        const colors = ['var(--source-color)', 'var(--payment-color)', 'var(--qrcode-color)'];
        
        Object.entries(types).forEach(([type, count], index) => {
          if (count === 0) return;
          
          const sliceAngle = (count / total) * 2 * Math.PI;
          ctx.fillStyle = colors[index];
          ctx.beginPath();
          ctx.moveTo(150, 100);
          ctx.arc(150, 100, 80, startAngle, startAngle + sliceAngle);
          ctx.closePath();
          ctx.fill();
          
          startAngle += sliceAngle;
        });
        
        ctx.fillStyle = 'white';
        ctx.font = '14px Inter';
        ctx.fillText('Transaction Types Distribution', 10, 20);
      }
    }
    
    // ======================
    // Enhanced UI Management
    // ======================
    class UIManager {
      static showPanel(type) {
        this.hidePanels();
        switch (type) {
          case 'wallet':
            if (DOM.walletPanel) DOM.walletPanel.style.display = 'block';
            WalletManager.updateUI();
            break;
          case 'analytics':
            if (DOM.analyticsPanel) DOM.analyticsPanel.style.display = 'block';
            AnalyticsManager.updateRealTimeStats();
            break;
          case 'storage':
            if (DOM.storagePanel) DOM.storagePanel.style.display = 'block';
            StorageManager.updateStorageUI();
            break;
          case 'details':
            if (DOM.detailsPanel) DOM.detailsPanel.style.display = 'block';
            break;
          case 'commodity':
            if (DOM.commodityPanel) {
              DOM.commodityPanel.style.cssText = `
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                position: fixed !important;
                top: 100px !important;
                right: 20px !important;
                width: 300px !important;
                z-index: 1000 !important;
                background: rgba(20, 20, 30, 0.95) !important;
                color: rgb(240, 240, 240) !important;
                border: 1px solid rgba(255, 255, 255, 0.2) !important;
                border-radius: 12px !important;
                padding: 15px !important;
              `;
              CommodityManager.updateCommodityUI();
            }
            break;
          default:
            console.log('Unknown panel type:', type);
        }
      }
      
      static hidePanel(type) {
        switch (type) {
          case 'wallet':
            if (DOM.walletPanel) DOM.walletPanel.style.display = 'none';
            break;
          case 'analytics':
            if (DOM.analyticsPanel) DOM.analyticsPanel.style.display = 'none';
            break;
          case 'storage':
            if (DOM.storagePanel) DOM.storagePanel.style.display = 'none';
            break;
          case 'details':
            if (DOM.detailsPanel) DOM.detailsPanel.style.display = 'none';
            break;
          case 'commodity':
            if (DOM.commodityPanel) DOM.commodityPanel.style.display = 'none';
            break;
        }
      }
      
      static hidePanels() {
        if (DOM.detailsPanel) DOM.detailsPanel.style.display = 'none';
        if (DOM.walletPanel) DOM.walletPanel.style.display = 'none';
        if (DOM.analyticsPanel) DOM.analyticsPanel.style.display = 'none';
        if (DOM.storagePanel) DOM.storagePanel.style.display = 'none';
        if (DOM.commodityPanel) DOM.commodityPanel.style.display = 'none';
      }
      
      static showTransactionDetails(txId) {
        // Find the transaction in either plane
        let tx = null;
        let txPlane = null;
        
        for (let plane = 1; plane <= 2; plane++) {
          const transactions = plane === 1 ? state.transactions1 : state.transactions2;
          const foundTx = transactions.find(t => t.id === txId);
          if (foundTx) {
            tx = foundTx;
            txPlane = plane;
            break;
          }
        }
        
        if (!tx) return;
        
        this.showPanel('details');
        
        const elements = {
          detailId: document.getElementById('detailId'),
          detailFrom: document.getElementById('detailFrom'),
          detailTo: document.getElementById('detailTo'),
          detailAmount: document.getElementById('detailAmount'),
          detailDesc: document.getElementById('detailDesc'),
          detailStatus: document.getElementById('detailStatus'),
          detailPlane: document.getElementById('detailPlane'),
          detailTs: document.getElementById('detailTs'),
          historyActions: document.getElementById('historyActions')
        };
        
        if (elements.detailId) elements.detailId.textContent = tx.id;
        if (elements.detailFrom) elements.detailFrom.textContent = tx.from;
        if (elements.detailTo) elements.detailTo.textContent = tx.to;
        if (elements.detailAmount) {
          let amountText = tx.asset === 'fiat' 
            ? Utils.formatCurrency(parseFloat(tx.amount))
            : `${parseFloat(tx.amount).toFixed(4)} ${tx.asset.toUpperCase()}`;
          if (tx.fiatValue) {
            amountText += ` (${Utils.formatCurrency(tx.fiatValue)})`;
          }
          if (tx.fee && tx.fee > 0) {
            amountText += ` (Fee: ${Utils.formatCurrency(tx.fee)})`;
          }
          elements.detailAmount.textContent = amountText;
        }
        if (elements.detailDesc) {
          let desc = tx.description;
          if (tx.paymentType === 'qrcode') desc += ' (QR Code Payment)';
          if (tx.asset !== 'fiat') desc += ` (${tx.asset.toUpperCase()} Transaction)`;
          elements.detailDesc.textContent = desc;
        }
        if (elements.detailStatus) {
          elements.detailStatus.innerHTML = `<span class="tx-status tx-status-${tx.status}">${tx.status}</span>`;
        }
        if (elements.detailPlane) elements.detailPlane.textContent = `Plane ${txPlane}`;
        if (elements.detailTs) elements.detailTs.textContent = Utils.formatDate(tx.timestamp);
        if (elements.historyActions) {
          elements.historyActions.style.display = state.ui.historyMode ? 'block' : 'none';
        }
      }
      
      static toggleHistoryMode() {
        state.ui.historyMode = !state.ui.historyMode;
        const button = document.getElementById('historyModeButton');
        if (button) button.classList.toggle('active', state.ui.historyMode);
        
        const historyActions = document.getElementById('historyActions');
        if (historyActions) {
          historyActions.style.display = state.ui.historyMode ? 'block' : 'none';
        }
        
        RenderEngine.requestDraw();
        NotificationManager.show(
          state.ui.historyMode ? 'History mode enabled' : 'History mode disabled',
          'default'
        );
      }
      
      static toggleTheme() {
        state.ui.darkTheme = !state.ui.darkTheme;
        document.body.style.filter = state.ui.darkTheme ? 'none' : 'invert(1) hue-rotate(180deg)';
        if (DOM.themeToggle) DOM.themeToggle.textContent = state.ui.darkTheme ? '🌙' : '☀️';
        RenderEngine.requestDraw();
      }
      
      static showShutdownModal() {
        if (DOM.shutdownModal) DOM.shutdownModal.style.display = 'flex';
      }
      
      static hideShutdownModal() {
        if (DOM.shutdownModal) DOM.shutdownModal.style.display = 'none';
      }
      
      static togglePlane() {
        // Toggle between plane 1 and plane 2
        state.ui.currentPlane = state.ui.currentPlane === 1 ? 2 : 1;
        
        // Update UI
        if (DOM.planeToggle) {
          DOM.planeToggle.classList.toggle('active', state.ui.currentPlane === 2);
        }
        
        if (DOM.planeLabel) {
          DOM.planeLabel.textContent = `Plane ${state.ui.currentPlane}`;
        }
        
        // Update transaction count
        TransactionManager.updateDisplay();
        
        // Re-center view for the new plane
        CanvasManager.centerView();
        
        // Request redraw
        RenderEngine.requestDraw();
        
        // Show notification
        const currentPlaneData = state.getCurrentPlaneData();
        const storage = currentPlaneData.storage;
        NotificationManager.show(`Switched to Plane ${state.ui.currentPlane} (${storage.used.toLocaleString()}/${storage.capacity.toLocaleString()})`, 'default');
      }
    }
    
    // ======================
    // Enhanced Notification System
    // ======================
    class NotificationManager {
      static queue = [];
      static isShowing = false;
      
      static show(message, type = 'default', duration = 3000) {
        this.queue.push({ message, type, duration });
        this.processQueue();
      }
      
      static processQueue() {
        if (this.isShowing || this.queue.length === 0) return;
        
        const { message, type, duration } = this.queue.shift();
        this.displayNotification(message, type, duration);
      }
      
      static displayNotification(message, type, duration) {
        this.isShowing = true;
        
        if (DOM.notification) {
          DOM.notification.textContent = message;
          DOM.notification.className = 'notification';
          
          if (type !== 'default') {
            DOM.notification.classList.add(`notification-${type}`);
          }
          
          DOM.notification.classList.add('show');
          
          setTimeout(() => {
            DOM.notification.classList.remove('show');
            this.isShowing = false;
            setTimeout(() => this.processQueue(), 400);
          }, duration);
        }
      }
    }
    
    // ======================
    // Enhanced QR Code System
    // ======================
    class QRCodeManager {
      static generateQRCode(amount, note = '') {
        state.currentQRCode = {
          recipient: state.userWallet.id,
          amount: amount,
          note: note,
          timestamp: new Date().toISOString()
        };
        
        const qrAmount = document.getElementById('qrAmount');
        const qrRecipient = document.getElementById('qrRecipient');
        
        if (qrAmount) qrAmount.textContent = Utils.formatCurrency(amount);
        if (qrRecipient) qrRecipient.textContent = state.userWallet.id;
        
        this.renderQRCode();
        if (DOM.qrcodeModal) DOM.qrcodeModal.style.display = 'flex';
        NotificationManager.show('QR Code generated! Share with the payer.', 'qrcode-notification');
      }
      
      static renderQRCode() {
        const canvas = document.getElementById('qrcodeCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 200, 200);
        
        // Enhanced QR code pattern
        ctx.fillStyle = 'black';
        const cellSize = 8;
        const gridSize = 25;
        
        // Generate more realistic QR pattern
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const shouldFill = this.getQRPattern(x, y, gridSize);
            if (shouldFill) {
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
        
        // Draw position detection patterns (corners)
        this.drawPositionMarkers(ctx, cellSize);
      }
      
      static getQRPattern(x, y, size) {
        // Simulate QR code data pattern
        const hash = (x * 31 + y * 17 + state.currentQRCode.amount * 13) % 100;
        return hash > 45 || this.isPositionMarker(x, y, size) || this.isTimingPattern(x, y, size);
      }
      
      static isPositionMarker(x, y, size) {
        const markers = [
          { x: 0, y: 0 }, // Top-left
          { x: size - 7, y: 0 }, // Top-right
          { x: 0, y: size - 7 } // Bottom-left
        ];
        
        return markers.some(marker => 
          x >= marker.x && x < marker.x + 7 && 
          y >= marker.y && y < marker.y + 7
        );
      }
      
      static isTimingPattern(x, y, size) {
        return (x === 6 && y > 7 && y < size - 8) || (y === 6 && x > 7 && x < size - 8);
      }
      
      static drawPositionMarkers(ctx, cellSize) {
        const positions = [
          { x: 0, y: 0 },
          { x: 17 * cellSize, y: 0 },
          { x: 0, y: 17 * cellSize }
        ];
        
        positions.forEach(pos => {
          // Outer square
          ctx.fillRect(pos.x, pos.y, 7 * cellSize, 7 * cellSize);
          ctx.fillStyle = 'white';
          ctx.fillRect(pos.x + cellSize, pos.y + cellSize, 5 * cellSize, 5 * cellSize);
          ctx.fillStyle = 'black';
          ctx.fillRect(pos.x + 2 * cellSize, pos.y + 2 * cellSize, 3 * cellSize, 3 * cellSize);
        });
      }
      
      static processQRPayment(qrData) {
        if (!qrData || !qrData.recipient || !qrData.amount) {
          NotificationManager.show('Invalid QR Code data!', 'error');
          return false;
        }
        
        if (qrData.recipient === state.userWallet.id) {
          NotificationManager.show('Cannot pay yourself!', 'warning');
          return false;
        }
        
        return WalletManager.processPayment(qrData.recipient, qrData.amount, qrData.note, 'standard', 'qrcode');
      }
      
      static simulateQRScan() {
        // Simulate scanning a QR code with sample data
        const sampleQRData = {
          recipient: 'DL-DEMO-' + Math.random().toString(36).substr(2, 8).toUpperCase(),
          amount: Math.floor(Math.random() * 100) + 10,
          note: 'QR Code Payment',
          timestamp: new Date().toISOString()
        };
        
        if (this.processQRPayment(sampleQRData)) {
          if (DOM.scanModal) DOM.scanModal.style.display = 'none';
          NotificationManager.show(`QR payment of ${Utils.formatCurrency(sampleQRData.amount)} processed!`, 'success');
        }
      }
    }
    
    // ======================
    // Enhanced Interaction Management
    // ======================
    class InteractionManager {
      static getBlockAtPosition(x, y) {
        if (state.ui.zoom < RenderEngine.SIMPLE_THRESHOLD) return -1;
        
        const blockSize = 40 * state.ui.zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Check visible blocks only for performance
        const visibleBlocks = RenderEngine.getVisibleBlocks(hexWidth, hexHeight);
        
        for (let i = visibleBlocks.length - 1; i >= 0; i--) {
          const { index, pos } = visibleBlocks[i];
          const dx = x - pos.x;
          const dy = y - pos.y;
          
          // Use hexagon collision detection
          if (this.isPointInHexagon(dx, dy, blockSize)) {
            return index;
          }
        }
        
        return -1;
      }
      
      static isPointInHexagon(x, y, radius) {
        // Simplified hexagon collision detection
        const distance = Math.sqrt(x * x + y * y);
        return distance <= radius;
      }
      
      static handleMouseMove(e) {
        if (!state.ui.isAuthenticated) return;
        
        if (state.ui.dragging) {
          if (DOM.canvas) DOM.canvas.style.cursor = 'grabbing';
          const deltaX = e.clientX - state.ui.lastMousePos.x;
          const deltaY = e.clientY - state.ui.lastMousePos.y;
          
          state.ui.dragOffset.x += deltaX;
          state.ui.dragOffset.y += deltaY;
          state.ui.lastMousePos = { x: e.clientX, y: e.clientY };
          
          RenderEngine.requestDraw();
        } else {
          const rect = DOM.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          const newHoveredIndex = this.getBlockAtPosition(mouseX, mouseY);
          
          if (newHoveredIndex !== state.ui.hoveredBlockIndex) {
            state.ui.hoveredBlockIndex = newHoveredIndex;
            if (DOM.canvas) DOM.canvas.style.cursor = newHoveredIndex >= 0 ? 'pointer' : 'grab';
            RenderEngine.requestDraw();
          }
        }
      }
      
      static handleMouseDown(e) {
        if (!state.ui.isAuthenticated) return;
        state.ui.dragging = true;
        state.ui.lastMousePos = { x: e.clientX, y: e.clientY };
      }
      
      static handleMouseUp() {
        state.ui.dragging = false;
        if (DOM.canvas) DOM.canvas.style.cursor = 'grab';
      }
      
      static handleClick() {
        if (!state.ui.isAuthenticated) return;
        
        if (state.ui.hoveredBlockIndex !== -1) {
          const currentPlaneData = state.getCurrentPlaneData();
          const block = currentPlaneData.blocks[state.ui.hoveredBlockIndex];
          state.ui.selectedTxId = block.txId;
          UIManager.showTransactionDetails(block.txId);
          RenderEngine.requestDraw();
        } else {
          state.ui.selectedTxId = null;
          UIManager.hidePanels();
          RenderEngine.requestDraw();
        }
      }
      
      static handleWheel(e) {
        if (!state.ui.isAuthenticated) return;
        
        e.preventDefault();
        
        if (e.ctrlKey || e.metaKey) {
          // Zoom
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          const newZoom = Utils.clamp(state.ui.zoom * zoomFactor, 0.1, 5);
          
          state.ui.zoom = newZoom;
          if (DOM.zoomSlider) DOM.zoomSlider.value = newZoom;
          if (DOM.zoomDisplay) DOM.zoomDisplay.textContent = newZoom.toFixed(1) + 'x';
          RenderEngine.updateZoomInfo();
        } else {
          // Pan
          state.ui.dragOffset.x -= e.deltaX;
          state.ui.dragOffset.y -= e.deltaY;
        }
        
        RenderEngine.requestDraw();
      }
      
      static handleKeyboard(e) {
        if (!state.ui.isAuthenticated) return;
        
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case 's':
              e.preventDefault();
              DataManager.saveToStorage();
              break;
            case 'o':
              e.preventDefault();
              DataManager.loadFromStorage();
              break;
            case '=':
            case '+':
              e.preventDefault();
              state.ui.zoom = Utils.clamp(state.ui.zoom + 0.1, 0.1, 5);
              this.updateZoomUI();
              break;
            case '-':
              e.preventDefault();
              state.ui.zoom = Utils.clamp(state.ui.zoom - 0.1, 0.1, 5);
              this.updateZoomUI();
              break;
          }
        }
        
        // Escape key to close panels
        if (e.key === 'Escape') {
          UIManager.hidePanels();
          state.ui.selectedTxId = null;
          RenderEngine.requestDraw();
        }
      }
      
      static updateZoomUI() {
        if (DOM.zoomSlider) DOM.zoomSlider.value = state.ui.zoom;
        if (DOM.zoomDisplay) DOM.zoomDisplay.textContent = state.ui.zoom.toFixed(1) + 'x';
        RenderEngine.updateZoomInfo();
        RenderEngine.requestDraw();
      }
    }
    
    // ======================
    // Enhanced Data Management
    // ======================
    class DataManager {
      static saveToStorage() {
        try {
          const saveData = {
            transactions1: state.transactions1,
            transactions2: state.transactions2,
            wallet: state.userWallet,
            storage: state.storage,
            version: '3.1.0',
            timestamp: new Date().toISOString()
          };
          
          localStorage.setItem('blockchainLedger_v3_1', JSON.stringify(saveData));
          NotificationManager.show('Ledger saved successfully!', 'success');
        } catch (e) {
          console.error('Error saving to storage:', e);
          NotificationManager.show('Failed to save: Storage quota exceeded', 'error');
        }
      }
      
      static loadFromStorage() {
        try {
          const saved = localStorage.getItem('blockchainLedger_v3_1');
          if (!saved) {
            // Try legacy format
            return this.loadLegacyFormat();
          }
          
          const data = JSON.parse(saved);
          
          if (data.transactions1 && data.transactions2) {
            TransactionManager.clearLedger();
            
            // Load transactions for both planes
            data.transactions1.forEach(tx => {
              state.transactions1.push(tx);
              state.blocks1.push({ type: 'source', txId: tx.id, data: tx, plane: 1 });
              state.blocks1.push({ type: 'destination', txId: tx.id, data: tx, plane: 1 });
              state.storage.plane1.transactions.push(tx.id);
            });
            
            data.transactions2.forEach(tx => {
              state.transactions2.push(tx);
              state.blocks2.push({ type: 'source', txId: tx.id, data: tx, plane: 2 });
              state.blocks2.push({ type: 'destination', txId: tx.id, data: tx, plane: 2 });
              state.storage.plane2.transactions.push(tx.id);
            });
            
            // Update storage counts
            state.storage.plane1.used = state.transactions1.length;
            state.storage.plane2.used = state.transactions2.length;
            
            if (data.wallet) {
              state.userWallet = { ...state.userWallet, ...data.wallet };
              WalletManager.updateUI();
            }
            
            if (data.storage) {
              state.storage.allocationStrategy = data.storage.allocationStrategy || 'balanced';
            }
            
            TransactionManager.updateDisplay();
            AnalyticsManager.updateRealTimeStats();
            StorageManager.updateStorageUI();
            NotificationManager.show(`Loaded ${(data.transactions1.length + data.transactions2.length).toLocaleString()} transactions!`, 'success');
          }
        } catch (e) {
          console.error('Error loading from storage:', e);
          NotificationManager.show('Failed to load ledger: Invalid format', 'error');
        }
      }
      
      static loadLegacyFormat() {
        const legacy = localStorage.getItem('blockchainLedger_v3');
        if (!legacy) {
          NotificationManager.show('No saved ledger found', 'warning');
          return;
        }
        
        try {
          const data = JSON.parse(legacy);
          if (data.transactions && Array.isArray(data.transactions)) {
            TransactionManager.clearLedger();
            
            // Migrate legacy transactions to dual plane system
            data.transactions.forEach((tx, index) => {
              const plane = (index % 2) + 1; // Alternate between planes
              StorageManager.addTransactionToPlane(tx, plane);
            });
            
            NotificationManager.show('Migrated legacy format to dual plane system!', 'success');
          }
        } catch (e) {
          console.error('Error loading legacy format:', e);
          NotificationManager.show('Failed to load legacy format', 'error');
        }
      }
      
      static exportData() {
        const exportData = {
          transactions1: state.transactions1,
          transactions2: state.transactions2,
          wallet: state.userWallet,
          storage: state.storage,
          metadata: {
            version: '3.1.0',
            exportDate: new Date().toISOString(),
            totalTransactions: state.getAllTransactions().length,
            totalVolume: state.analytics.totalVolume,
            plane1Usage: state.storage.plane1.used,
            plane2Usage: state.storage.plane2.used
          }
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `blockchain-ledger-dual-plane-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        NotificationManager.show('Ledger exported successfully!', 'success');
      }
    }
    
    // ======================
    // Enhanced Shutdown Management
    // ======================
    class ShutdownManager {
      static async shutdown() {
        if (state.ui.isShuttingDown) return;
        
        state.ui.isShuttingDown = true;
        
        try {
          // Save all data first
          await this.saveAllData();
          
          // Stop animation loop
          if (state.ui.animationFrameId) {
            cancelAnimationFrame(state.ui.animationFrameId);
            state.ui.animationFrameId = null;
          }
          
          // Clear UI
          UIManager.hidePanels();
          
          // Reset authentication state
          state.ui.isAuthenticated = false;
          
          // Clear canvas
          if (DOM.ctx) {
            DOM.ctx.clearRect(0, 0, DOM.canvas.width, DOM.canvas.height);
          }
          
          // Hide controls
          if (DOM.controls) DOM.controls.style.display = 'none';
          
          // Show shutdown complete message
          NotificationManager.show('Direct Ledger Wallet shutdown complete. Data saved successfully.', 'success');
          
          // Reset shutdown flag after a delay
          setTimeout(() => {
            state.ui.isShuttingDown = false;
          }, 2000);
          
        } catch (error) {
          console.error('Shutdown error:', error);
          NotificationManager.show('Error during shutdown. Some data may not have been saved.', 'error');
          state.ui.isShuttingDown = false;
        }
      }
      
      static async saveAllData() {
        try {
          // Save transactions
          const saveData = {
            transactions1: state.transactions1,
            transactions2: state.transactions2,
            wallet: state.userWallet,
            storage: state.storage,
            version: '3.1.0',
            timestamp: new Date().toISOString(),
            shutdownTime: new Date().toISOString()
          };
          
          localStorage.setItem('blockchainLedger_v3_1', JSON.stringify(saveData));
          
          // Also save to a backup location
          localStorage.setItem('blockchainLedger_backup', JSON.stringify(saveData));
        } catch (error) {
          console.error('Error saving data during shutdown:', error);
          throw error;
        }
      }
      
      static restart() {
        // Clear shutdown state
        state.ui.isShuttingDown = false;
        
        // Show controls
        if (DOM.controls) DOM.controls.style.display = 'flex';
        
        // Restart authentication
        authManager.checkPin();
      }
    }
    
    // ======================
    // Commodity UI Setup
    // ======================
    function addCommodityUI() {
      // Only set up the event listeners for the existing buttons
      document.getElementById('buyGoldButton')?.addEventListener('click', () => {
        const amount = parseFloat(prompt('Enter amount in fiat to spend on gold:', '100'));
        if (!isNaN(amount) && amount > 0) {
          CommodityManager.buyCommodityTokens(amount, 'gold');
        }
      });
      
      document.getElementById('sellGoldButton')?.addEventListener('click', () => {
        const amount = parseFloat(prompt('Enter amount of gold tokens to sell:', '0.1'));
        if (!isNaN(amount) && amount > 0) {
          CommodityManager.sellCommodityTokens(amount, 'gold');
        }
      });
      
      document.getElementById('buySilverButton')?.addEventListener('click', () => {
        const amount = parseFloat(prompt('Enter amount in fiat to spend on silver:', '100'));
        if (!isNaN(amount) && amount > 0) {
          CommodityManager.buyCommodityTokens(amount, 'silver');
        }
      });
      
      document.getElementById('sellSilverButton')?.addEventListener('click', () => {
        const amount = parseFloat(prompt('Enter amount of silver tokens to sell:', '1'));
        if (!isNaN(amount) && amount > 0) {
          CommodityManager.sellCommodityTokens(amount, 'silver');
        }
      });
    }
    
    // ======================
    // UI Adjustment Function
    // ======================
    function adjustUIElements() {
      const exitButton = document.getElementById('shutdownButton');
      if (exitButton) {
        exitButton.style.marginLeft = '50px';
        exitButton.style.paddingRight = '15px';
      }
      
      const modals = document.querySelectorAll('.modal');
      const panels = document.querySelectorAll('.panel');
      
      [...modals, ...panels].forEach(element => {
        element.style.backgroundColor = 'rgba(20, 20, 30, 0.95)';
        element.style.color = '#f0f0f0';
      });
      
      const historyElements = document.querySelectorAll('.payment-item, .tx-status');
      historyElements.forEach(element => {
        element.style.backgroundColor = 'rgba(30, 30, 40, 0.8)';
        element.style.color = '#e0e0e0';
      });
      
      const forkButton = document.getElementById('forkButton');
      if (forkButton) {
        forkButton.style.marginRight = '30px';
        forkButton.style.zIndex = '10';
        forkButton.style.position = 'relative';
        forkButton.style.display = 'inline-block';
        forkButton.style.visibility = 'visible';
      }
      
      const historyButton = document.getElementById('historyModeButton');
      if (historyButton) {
        historyButton.style.zIndex = '10';
        historyButton.style.position = 'relative';
        historyButton.style.display = 'inline-block';
        historyButton.style.visibility = 'visible';
      }
      
      const buttonContainer = exitButton?.parentElement;
      if (buttonContainer) {
        buttonContainer.style.gap = '20px';
        buttonContainer.style.overflow = 'visible';
      }
    }
    
    // ======================
    // Event Listeners Setup
    // ======================
    function setupEventListeners() {
      // Authentication
      if (DOM.pinSubmit) {
        DOM.pinSubmit.addEventListener('click', () => {
          authManager.validatePin(DOM.pinInput.value);
        });
      }
      
      if (DOM.pinInput) {
        DOM.pinInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            authManager.validatePin(DOM.pinInput.value);
          }
        });
      }
      
      // Shutdown
      if (DOM.shutdownButton) {
        DOM.shutdownButton.addEventListener('click', UIManager.showShutdownModal.bind(UIManager));
      }
      if (DOM.cancelShutdown) {
        DOM.cancelShutdown.addEventListener('click', UIManager.hideShutdownModal.bind(UIManager));
      }
      if (DOM.confirmShutdown) {
        DOM.confirmShutdown.addEventListener('click', () => {
          UIManager.hideShutdownModal();
          ShutdownManager.shutdown();
        });
      }
      
      // Canvas interactions
      if (DOM.canvas) {
        DOM.canvas.addEventListener('mousedown', InteractionManager.handleMouseDown.bind(InteractionManager));
        DOM.canvas.addEventListener('mouseup', InteractionManager.handleMouseUp.bind(InteractionManager));
        DOM.canvas.addEventListener('mousemove', Utils.throttle(InteractionManager.handleMouseMove.bind(InteractionManager), 16));
        DOM.canvas.addEventListener('click', InteractionManager.handleClick.bind(InteractionManager));
        DOM.canvas.addEventListener('wheel', InteractionManager.handleWheel.bind(InteractionManager), { passive: false });
        DOM.canvas.addEventListener('mouseleave', () => {
          state.ui.dragging = false;
          state.ui.hoveredBlockIndex = -1;
          RenderEngine.requestDraw();
        });
      }
      
      // Window events
      window.addEventListener('resize', Utils.debounce(CanvasManager.resizeCanvas.bind(CanvasManager), 250));
      window.addEventListener('keydown', InteractionManager.handleKeyboard.bind(InteractionManager));
      
      // UI Controls
      document.getElementById('addTxButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && DOM.txModal) DOM.txModal.style.display = 'flex';
      });
      
      document.getElementById('generateButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) TransactionManager.generateGalaxy(1000);
      });
      
      document.getElementById('clearButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && confirm('Clear entire ledger?')) {
          TransactionManager.clearLedger();
          NotificationManager.show('Ledger cleared', 'warning');
        }
      });
      
      document.getElementById('saveButton')?.addEventListener('click', DataManager.saveToStorage.bind(DataManager));
      document.getElementById('loadButton')?.addEventListener('click', DataManager.loadFromStorage.bind(DataManager));
      
      document.getElementById('paymentButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && DOM.paymentModal) DOM.paymentModal.style.display = 'flex';
      });
      
      document.getElementById('walletButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) UIManager.showPanel('wallet');
      });
      
      document.getElementById('analyticsButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) UIManager.showPanel('analytics');
      });
      
      document.getElementById('storageButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) {
          if (DOM.storageModal) {
            DOM.storageModal.style.display = 'flex';
            StorageManager.updateStorageUI();
          } else {
            UIManager.showPanel('storage');
          }
        }
      });
      
      const commodityButton = document.getElementById('commodityButton');
      if (commodityButton) {
        commodityButton.addEventListener('click', () => {
          if (state.ui.isAuthenticated) {
            UIManager.showPanel('commodity');
          } else {
            NotificationManager.show('Please authenticate first', 'warning');
          }
        });
      }
      
      document.getElementById('generateQRButton')?.addEventListener('click', () => {
        if (!state.ui.isAuthenticated) return;
        const amount = parseFloat(prompt('Enter amount for QR code:', '25.00'));
        if (!isNaN(amount) && amount > 0) {
          const note = prompt('Enter note (optional):', '') || '';
          QRCodeManager.generateQRCode(amount, note);
        }
      });
      
      document.getElementById('scanQRButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && DOM.scanModal) DOM.scanModal.style.display = 'flex';
      });
      
      document.getElementById('historyModeButton')?.addEventListener('click', UIManager.toggleHistoryMode.bind(UIManager));
      
      document.getElementById('forkButton')?.addEventListener('click', () => {
        if (state.ui.selectedTxId) {
          TransactionManager.forkTransaction(state.ui.selectedTxId);
        } else {
          NotificationManager.show('Select a transaction first!', 'warning');
        }
      });
      
      // Plane toggle
      if (DOM.planeToggle) {
        DOM.planeToggle.addEventListener('click', UIManager.togglePlane.bind(UIManager));
      }
      
      // Search and filter
      if (DOM.searchBox) {
        DOM.searchBox.addEventListener('input', Utils.debounce((e) => {
          state.ui.searchQuery = e.target.value.toLowerCase();
          RenderEngine.requestDraw();
        }, 300));
      }
      
      if (DOM.filterSelect) {
        DOM.filterSelect.addEventListener('change', (e) => {
          state.ui.filterType = e.target.value;
          RenderEngine.requestDraw();
        });
      }
      
      if (DOM.zoomSlider) {
        DOM.zoomSlider.addEventListener('input', (e) => {
          state.ui.zoom = parseFloat(e.target.value);
          if (DOM.zoomDisplay) DOM.zoomDisplay.textContent = state.ui.zoom.toFixed(1) + 'x';
          RenderEngine.updateZoomInfo();
          RenderEngine.requestDraw();
        });
      }
      
      // Theme toggle
      if (DOM.themeToggle) {
        DOM.themeToggle.addEventListener('click', UIManager.toggleTheme.bind(UIManager));
      }
      
      // Modal close buttons
      document.getElementById('closeTxModal')?.addEventListener('click', () => {
        if (DOM.txModal) DOM.txModal.style.display = 'none';
      });
      
      document.getElementById('closePaymentModal')?.addEventListener('click', () => {
        if (DOM.paymentModal) DOM.paymentModal.style.display = 'none';
      });
      
      document.getElementById('closeQRModal')?.addEventListener('click', () => {
        if (DOM.qrcodeModal) DOM.qrcodeModal.style.display = 'none';
      });
      
      document.getElementById('closeScanModal')?.addEventListener('click', () => {
        if (DOM.scanModal) DOM.scanModal.style.display = 'none';
      });
      
      document.getElementById('closeAnalyticsModal')?.addEventListener('click', () => {
        if (DOM.analyticsModal) DOM.analyticsModal.style.display = 'none';
      });
      
      document.getElementById('closeStorageModal')?.addEventListener('click', () => {
        if (DOM.storageModal) DOM.storageModal.style.display = 'none';
      });
      
      // Forms
      const txForm = document.getElementById('txForm');
      if (txForm) {
        txForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const formData = new FormData(e.target);
          const newTx = {
            from: document.getElementById('txFrom')?.value || '',
            to: document.getElementById('txTo')?.value || '',
            amount: parseFloat(document.getElementById('txAmount')?.value || 0),
            description: document.getElementById('txDesc')?.value || 'Manual Transaction'
          };
          
          const targetPlane = document.getElementById('txPlane')?.value || 'auto';
          
          if (TransactionManager.addTransaction(newTx, targetPlane)) {
            if (DOM.txModal) DOM.txModal.style.display = 'none';
            e.target.reset();
          }
        });
      }
      
      const paymentForm = document.getElementById('paymentForm');
      if (paymentForm) {
        paymentForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const recipient = document.getElementById('paymentRecipient')?.value || '';
          const amount = parseFloat(document.getElementById('paymentAmount')?.value || 0);
          const note = document.getElementById('paymentNote')?.value || '';
          const speed = document.getElementById('paymentSpeed')?.value || 'standard';
          
          if (WalletManager.processPayment(recipient, amount, note, speed)) {
            if (DOM.paymentModal) DOM.paymentModal.style.display = 'none';
            e.target.reset();
          }
        });
      }
      
      // Storage management
      document.getElementById('optimizeStorage')?.addEventListener('click', () => {
        StorageManager.optimizeStorage();
      });
      
      document.getElementById('clearPlane1')?.addEventListener('click', () => {
        if (confirm('Clear all transactions from Plane 1?')) {
          StorageManager.clearPlane(1);
        }
      });
      
      document.getElementById('clearPlane2')?.addEventListener('click', () => {
        if (confirm('Clear all transactions from Plane 2?')) {
          StorageManager.clearPlane(2);
        }
      });
      
      // Allocation strategy selection
      document.querySelectorAll('.allocation-option').forEach(option => {
        option.addEventListener('click', () => {
          const strategy = option.dataset.strategy;
          StorageManager.setAllocationStrategy(strategy);
        });
      });
      
      // QR Code simulation
      document.getElementById('simulateScan')?.addEventListener('click', QRCodeManager.simulateQRScan.bind(QRCodeManager));
    }
    
    // ======================
    // Global Functions (for onclick handlers)
    // ======================
    window.moveTransaction = function() {
      NotificationManager.show('Move functionality: Drag to reorder timeline!', 'default');
    };
    
    window.deleteTransaction = function() {
      if (state.ui.selectedTxId && confirm('Delete this transaction from history?')) {
        TransactionManager.deleteTransaction(state.ui.selectedTxId);
      }
    };
    
    window.forkFromHere = function() {
      if (state.ui.selectedTxId) {
        TransactionManager.forkTransaction(state.ui.selectedTxId);
      }
    };
    
    window.moveToOtherPlane = function() {
      if (state.ui.selectedTxId) {
        const targetPlane = state.ui.currentPlane === 1 ? 2 : 1;
        StorageManager.moveTransactionToPlane(state.ui.selectedTxId, targetPlane);
      }
    };
    
    window.openPaymentModal = function() {
      if (DOM.paymentModal) DOM.paymentModal.style.display = 'flex';
    };
    
    window.addFunds = function() {
      const amount = parseFloat(prompt('Enter amount to add:', '100.00'));
      if (!isNaN(amount) && amount > 0) {
        WalletManager.addFunds(amount);
      }
    };
    
    window.openStorageModal = function() {
      if (DOM.storageModal) {
        DOM.storageModal.style.display = 'flex';
        StorageManager.updateStorageUI();
      }
    };
    
    window.restartLedger = function() {
      if (confirm('Restart the Direct Ledger Wallet?')) {
        ShutdownManager.restart();
      }
    };
    
    // ======================
    // Enhanced Application Initialization
    // ======================
    function initializeApp() {
      setupEventListeners();
      
      addCommodityUI();
      
      setInterval(() => {
        CommodityManager.updatePrices();
      }, 30000);
      
      RenderEngine.animate();
      authManager.checkPin();
      
      adjustUIElements();
      
      console.log(`
🚀 Enhanced Blockchain Ledger v3.1.0 Loaded!
🪙 Now with Gold and Silver backing!
💾 Dual Plane Storage System - Real additional capacity!
📊 Total storage capacity: 20,000 transactions (10,000 per plane)

Features:
• Automatic transaction allocation between planes
• Storage optimization and management
• Move transactions between planes
• Visual storage monitoring
• Multiple allocation strategies

Keyboard shortcuts:
• Ctrl/Cmd + S: Save ledger
• Ctrl/Cmd + O: Load ledger  
• Ctrl/Cmd + Plus: Zoom in
• Ctrl/Cmd + Minus: Zoom out
• Escape: Close panels
• Mouse wheel + Ctrl: Zoom
• Mouse wheel: Pan
• Shutdown button: Power off ledger
      `);
    }
    
    document.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>
