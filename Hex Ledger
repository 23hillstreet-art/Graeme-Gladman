<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced Scalable Temporal Blockchain Ledger</title>
  <style>
    :root {
        --source-color: #3498db;
        --dest-color: #2ecc71;
        --rung-color: #e74c3c;
        --highlight-color: #f1c40f;
        --bg-color-1: #0a0a0f;
        --bg-color-2: #1a1a2e;
        --bg-color-3: #16213e;
        --pixel-glow: #ffffff;
        --fork-color: #9b59b6;
        --payment-color: #16a085;
        --qrcode-color: #2c3e50;
        --success-color: #27ae60;
        --warning-color: #f39c12;
        --error-color: #e74c3c;
        --glass-bg: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
        --shadow-color: rgba(0, 0, 0, 0.3);
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, var(--bg-color-1) 0%, var(--bg-color-2) 50%, var(--bg-color-3) 100%);
      color: #ecf0f1;
      font-size: 14px;
      transition: filter 0.3s ease;
    }
    
    /* Enhanced Glass Morphism Effects */
    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      box-shadow: 0 8px 32px var(--shadow-color);
    }
    
    .glass-strong {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
    }
    
    /* Improved Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(5px);
      justify-content: center;
      align-items: center;
      animation: modalFadeIn 0.3s ease;
    }
    
    @keyframes modalFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .modal-content {
      background: linear-gradient(145deg, var(--bg-color-2), var(--bg-color-3));
      padding: 2rem;
      border-radius: 20px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      border: 1px solid var(--glass-border);
      position: relative;
      transform: scale(0.9);
      animation: modalSlideIn 0.3s ease forwards;
    }
    
    @keyframes modalSlideIn {
      to { transform: scale(1); }
    }
    
    /* Enhanced Input Styles */
    .form-input {
      width: 100%;
      padding: 12px 16px;
      margin: 8px 0;
      border-radius: 12px;
      border: 2px solid var(--glass-border);
      background: var(--glass-bg);
      color: white;
      font-size: 1rem;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .form-input:focus {
      border-color: var(--highlight-color);
      box-shadow: 0 0 0 3px rgba(241, 196, 64, 0.2);
      outline: none;
    }
    
    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    /* Enhanced Button Styles */
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 12px;
      color: white;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #667eea, #764ba2);
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn:hover { 
      transform: translateY(-2px); 
      box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--highlight-color), #f39c12);
      box-shadow: 0 4px 15px rgba(241, 196, 64, 0.4);
    }
    
    .btn-success {
      background: linear-gradient(135deg, var(--success-color), #2ecc71);
      box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
    }
    
    .btn-payment {
      background: linear-gradient(135deg, var(--payment-color), #1abc9c);
      box-shadow: 0 4px 15px rgba(22, 160, 133, 0.4);
    }
    
    .btn-qr {
      background: linear-gradient(135deg, var(--qrcode-color), #34495e);
      box-shadow: 0 4px 15px rgba(44, 62, 80, 0.4);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, var(--error-color), #c0392b);
      box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
    }
    
    .btn-small {
      padding: 8px 16px;
      font-size: 0.8rem;
    }
    
    .btn.active {
      background: linear-gradient(135deg, var(--highlight-color), #f39c12);
      box-shadow: 0 0 25px rgba(241, 196, 64, 0.8);
    }
    
    /* Enhanced Controls */
    #controls {
      padding: 1rem;
      background: var(--glass-bg);
      backdrop-filter: blur(25px);
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
      box-shadow: 0 4px 30px var(--shadow-color);
      border-bottom: 1px solid var(--glass-border);
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: var(--glass-bg);
      border-radius: 12px;
      border: 1px solid var(--glass-border);
    }
    
    .control-label {
      font-size: 0.8rem;
      opacity: 0.8;
      font-weight: 500;
    }
    
    /* Enhanced Search and Filter */
    .search-container {
      position: relative;
      min-width: 280px;
    }
    
    .search-input {
      width: 100%;
      padding: 10px 40px 10px 16px;
      border-radius: 12px;
      border: 2px solid var(--glass-border);
      background: var(--glass-bg);
      color: white;
      backdrop-filter: blur(15px);
      transition: all 0.3s ease;
    }
    
    .search-input:focus {
      border-color: var(--highlight-color);
      box-shadow: 0 0 0 3px rgba(241, 196, 64, 0.2);
    }
    
    .search-icon {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0.5;
    }
    
    /* Enhanced Status Display */
    .status-display {
      font-weight: 600;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      font-size: 0.9rem;
    }
    
    /* Enhanced Canvas */
    canvas { 
      display: block; 
      cursor: grab; 
      image-rendering: crisp-edges;
      transition: filter 0.3s ease;
    }
    canvas:active { cursor: grabbing; }
    
    /* Enhanced Panels */
    .panel {
      position: fixed;
      width: 350px;
      background: var(--glass-strong);
      backdrop-filter: blur(25px);
      border-radius: 20px;
      padding: 1.5rem;
      z-index: 150;
      box-shadow: 0 20px 60px var(--shadow-color);
      border: 1px solid var(--glass-border);
      animation: panelSlideIn 0.4s ease;
    }
    
    @keyframes panelSlideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .details-panel {
      left: 20px;
      bottom: 20px;
      display: none;
    }
    
    .wallet-panel {
      right: 20px;
      bottom: 20px;
      display: none;
    }
    
    .analytics-panel {
      right: 20px;
      top: 100px;
      display: none;
    }
    
    .panel h3 { 
      margin-top: 0; 
      border-bottom: 2px solid var(--highlight-color); 
      padding-bottom: 0.5rem;
      color: var(--highlight-color);
      font-size: 1.2rem;
    }
    
    .panel p { 
      margin: 0.5rem 0; 
      line-height: 1.6; 
    }
    
    /* Enhanced Wallet Styles */
    .wallet-balance {
      background: linear-gradient(145deg, rgba(22, 160, 133, 0.2), rgba(22, 160, 133, 0.1));
      padding: 1.5rem;
      border-radius: 16px;
      margin-bottom: 1rem;
      text-align: center;
      border: 1px solid var(--payment-color);
      position: relative;
      overflow: hidden;
    }
    
    .wallet-balance::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(from 0deg, transparent, rgba(22, 160, 133, 0.1), transparent);
      animation: rotate 10s linear infinite;
      z-index: -1;
    }
    
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    
    .balance-amount {
      font-size: 2rem;
      font-weight: 800;
      background: linear-gradient(135deg, #16a085, #1abc9c);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Enhanced QR Code */
    .qrcode-container {
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: white;
      border-radius: 16px;
      display: inline-block;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      position: relative;
    }
    
    .qrcode-container::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--qrcode-color), var(--payment-color));
      border-radius: 18px;
      z-index: -1;
    }
    
    /* Enhanced Notifications */
    .notification {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: linear-gradient(135deg, var(--success-color), #2ecc71);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 200;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(10px);
      max-width: 300px;
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .notification-payment {
      background: linear-gradient(135deg, var(--payment-color), #1abc9c);
    }
    
    .notification-qrcode {
      background: linear-gradient(135deg, var(--qrcode-color), #34495e);
    }
    
    .notification-warning {
      background: linear-gradient(135deg, var(--warning-color), #f39c12);
    }
    
    .notification-error {
      background: linear-gradient(135deg, var(--error-color), #c0392b);
    }
    
    /* Enhanced Info Panel */
    .info-panel {
      position: fixed;
      top: 120px;
      right: 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      padding: 1rem;
      border-radius: 16px;
      border: 1px solid var(--glass-border);
      font-size: 0.9em;
      max-width: 250px;
      box-shadow: 0 10px 30px var(--shadow-color);
    }
    
    /* Performance Indicator */
    .performance-indicator {
      position: fixed;
      top: 20px;
      left: 20px;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      border: 1px solid var(--glass-border);
      font-size: 0.8rem;
      backdrop-filter: blur(15px);
    }
    
    .fps-counter {
      color: var(--success-color);
      font-weight: 600;
    }
    
    /* Loading Spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: var(--highlight-color);
      animation: spin 0.8s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Transaction Status Badges */
    .tx-status {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .tx-status-pending {
      background: rgba(241, 196, 64, 0.2);
      color: var(--warning-color);
      border: 1px solid var(--warning-color);
    }
    
    .tx-status-completed {
      background: rgba(39, 174, 96, 0.2);
      color: var(--success-color);
      border: 1px solid var(--success-color);
    }
    
    .tx-status-failed {
      background: rgba(231, 76, 60, 0.2);
      color: var(--error-color);
      border: 1px solid var(--error-color);
    }
    
    /* Analytics Charts */
    .chart-container {
      margin: 1rem 0;
      padding: 1rem;
      background: var(--glass-bg);
      border-radius: 12px;
      border: 1px solid var(--glass-border);
    }
    
    .chart-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--highlight-color);
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      #controls {
        padding: 0.5rem;
        gap: 0.3rem;
      }
      
      .control-group {
        flex-direction: column;
        gap: 0.3rem;
        padding: 0.3rem;
      }
      
      .btn {
        padding: 8px 12px;
        font-size: 0.8rem;
      }
      
      .search-container {
        min-width: 200px;
      }
      
      .panel {
        width: 300px;
        padding: 1rem;
      }
      
      .modal-content {
        width: 95%;
        padding: 1.5rem;
      }
    }
    
    /* Dark Theme Toggle - Fixed positioning */
    .theme-toggle {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 200;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(15px);
    }
    
    .theme-toggle:hover {
      background: var(--glass-strong);
      transform: scale(1.1);
    }
    
    /* Shutdown Button */
    .shutdown-button {
      position: fixed;
      top: 20px;
      right: 80px;
      z-index: 200;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(15px);
      color: var(--error-color);
      font-size: 1.2rem;
    }
    
    .shutdown-button:hover {
      background: var(--glass-strong);
      transform: scale(1.1);
      color: var(--error-color);
    }
    
    /* Shutdown Modal */
    .shutdown-modal .modal-content {
      text-align: center;
      max-width: 400px;
    }
    
    .shutdown-modal h2 {
      color: var(--error-color);
      margin-bottom: 1rem;
    }
    
    .shutdown-modal p {
      margin-bottom: 1.5rem;
      line-height: 1.6;
    }
    
    .shutdown-actions {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }
 </style>
</head>
<body>
  <!-- Performance Indicator -->
  <div class="performance-indicator">
    FPS: <span class="fps-counter" id="fpsCounter">60</span> | 
    Blocks: <span id="blockCounter">0</span>
  </div>
  
  <!-- Shutdown Button -->
  <div class="shutdown-button" id="shutdownButton" title="Shutdown Ledger">
    ⏻
  </div>
  
  <!-- Theme Toggle -->
  <div class="theme-toggle" id="themeToggle" title="Toggle Theme">
    🌙
  </div>
  
  <!-- PIN Modal -->
  <div id="pinModal" class="modal">
    <div class="modal-content">
      <h2>🔐 Secure Access</h2>
      <input type="password" id="pinInput" class="form-input" maxlength="4" placeholder="Enter 4-digit PIN">
      <div id="pinMessage" style="margin: 1rem 0; color: var(--warning-color);"></div>
      <button id="pinSubmit" class="btn btn-primary">Access Ledger</button>
    </div>
  </div>
  
  <!-- Shutdown Modal -->
  <div id="shutdownModal" class="modal shutdown-modal">
    <div class="modal-content">
      <h2>⚠️ Shutdown Ledger</h2>
      <p>Are you sure you want to shutdown the Direct Ledger Wallet? This will:</p>
      <ul style="text-align: left; margin: 1rem 0;">
        <li>Save all transactions to local storage</li>
        <li>Clear the current session</li>
        <li>Require PIN to access again</li>
      </ul>
      <div class="shutdown-actions">
        <button id="cancelShutdown" class="btn">Cancel</button>
        <button id="confirmShutdown" class="btn btn-danger">Shutdown</button>
      </div>
    </div>
  </div>
  
  <!-- Transaction Modal -->
  <div id="txModal" class="modal">
    <div class="modal-content">
      <button id="closeTxModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>✨ Add Transaction</h2>
      <form id="txForm">
        <label class="control-label">From:</label>
        <input type="text" id="txFrom" class="form-input" required>
        
        <label class="control-label">To:</label>
        <input type="text" id="txTo" class="form-input" required>
        
        <label class="control-label">Amount:</label>
        <input type="number" id="txAmount" class="form-input" step="0.01" min="0.01" required>
        
        <label class="control-label">Description:</label>
        <input type="text" id="txDesc" class="form-input" placeholder="Optional description">
        
        <button type="submit" class="btn btn-success" style="margin-top: 1rem;">Add Transaction</button>
      </form>
    </div>
  </div>
  
  <!-- Payment Modal -->
  <div id="paymentModal" class="modal">
    <div class="modal-content">
      <button id="closePaymentModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>💳 DirectLedger Payment</h2>
      <div class="wallet-balance">
        <h3>Your Balance</h3>
        <div class="balance-amount" id="walletBalance">$0.00</div>
      </div>
      <form id="paymentForm">
        <label class="control-label">Recipient ID:</label>
        <input type="text" id="paymentRecipient" class="form-input" placeholder="Enter recipient's wallet ID" required>
        
        <label class="control-label">Amount:</label>
        <input type="number" id="paymentAmount" class="form-input" step="0.01" min="0.01" required>
        
        <label class="control-label">Note (optional):</label>
        <input type="text" id="paymentNote" class="form-input" placeholder="What's this payment for?">
        
        <label class="control-label">Transfer Speed:</label>
        <select id="paymentSpeed" class="form-input">
          <option value="instant">⚡ Instant (0.5% fee)</option>
          <option value="fast" selected>🚀 Fast (0.2% fee)</option>
          <option value="standard">📦 Standard (no fee)</option>
        </select>
        
        <button type="submit" class="btn btn-payment" style="margin-top: 1rem;">Send Payment</button>
      </form>
    </div>
  </div>
  
  <!-- QR Code Modal -->
  <div id="qrcodeModal" class="modal">
    <div class="modal-content" style="text-align: center;">
      <button id="closeQRModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>📱 Payment QR Code</h2>
      <div class="qrcode-container">
        <canvas id="qrcodeCanvas" width="200" height="200"></canvas>
      </div>
      <div style="margin-top: 1rem; font-size: 1.1rem;">
        <div>Amount: <span style="font-weight: bold; color: var(--payment-color); font-size: 1.3rem;" id="qrAmount">$0.00</span></div>
        <div style="margin-top: 0.5rem;">To: <span id="qrRecipient" style="font-family: monospace;">Your Wallet</span></div>
      </div>
      <p style="margin-top: 1rem; opacity: 0.8;">Show this QR code to the payer or share it with them</p>
    </div>
  </div>
  
  <!-- Scan QR Code Modal -->
  <div id="scanModal" class="modal">
    <div class="modal-content" style="text-align: center;">
      <button id="closeScanModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>📷 Scan QR Code</h2>
      <div style="margin: 1.5rem 0; height: 300px; background: rgba(0,0,0,0.3); border-radius: 16px; display: flex; justify-content: center; align-items: center; border: 2px dashed var(--qrcode-color);">
        <div style="color: var(--qrcode-color); font-size: 1.2rem; text-align: center;">
          <div style="font-size: 3rem;">📷</div>
          <div style="margin-top: 1rem;">Point camera at QR code</div>
        </div>
      </div>
      <p style="opacity: 0.8; font-size: 0.9rem;">Camera access would be implemented in a real application</p>
      <button id="simulateScan" class="btn btn-qr">Simulate QR Scan</button>
    </div>
  </div>
  
  <div id="analyticsModal" class="modal">
    <div class="modal-content">
      <button id="closeAnalyticsModal" class="btn btn-small" style="position: absolute; right: 1rem; top: 1rem;">✕</button>
      <h2>📊 Analytics Dashboard</h2>
      <div class="chart-container">
        <h4 class="chart-title">Transaction Volume</h4>
        <canvas id="volumeChart" width="600" height="200"></canvas>
      </div>
      <div class="chart-container">
        <h4 class="chart-title">Transaction Types</h4>
        <canvas id="typeChart" width="300" height="200"></canvas>
      </div>
    </div>
  </div>
  
  <!-- Main Controls -->
  <div id="controls" class="glass">
    <div class="control-group">
      <button id="addTxButton" class="btn">✨ Add Transaction</button>
      <button id="generateButton" class="btn">🌌 Generate Galaxy</button>
      <button id="clearButton" class="btn">🗑️ Clear Ledger</button>
    </div>
    
    <div class="control-group">
      <button id="paymentButton" class="btn btn-payment">💳 Payment</button>
      <button id="walletButton" class="btn btn-payment">👛 Wallet</button>
      <button id="analyticsButton" class="btn">📊 Analytics</button>
      <!-- FIXED: Added commodity button to controls -->
      <button id="commodityButton" class="btn">🪙 Commodities</button>
    </div>
    
    <div class="control-group">
      <button id="generateQRButton" class="btn btn-qr">📱 Generate QR</button>
      <button id="scanQRButton" class="btn btn-qr">📷 Scan QR</button>
    </div>
    
    <div class="control-group">
      <button id="historyModeButton" class="btn">⏳ History Mode</button>
      <button id="forkButton" class="btn">🔀 Fork Timeline</button>
    </div>
    
    <div class="control-group search-container">
      <input type="search" id="searchBox" class="search-input" placeholder="Search transactions...">
      <span class="search-icon">🔍</span>
    </div>
    
    <div class="control-group">
      <select id="filterSelect" class="form-input" style="min-width: 140px;">
        <option value="all">All Types</option>
        <option value="source">Source Only</option>
        <option value="destination">Destination Only</option>
        <option value="payment">Payments Only</option>
        <option value="qrcode">QR Payments</option>
      </select>
    </div>
    
    <div class="control-group">
      <button id="saveButton" class="btn">💾 Save</button>
      <button id="loadButton" class="btn">📂 Load</button>
    </div>
    
    <div class="control-group">
      <label class="control-label">Zoom:</label>
      <input type="range" id="zoomSlider" min="0.1" max="5" value="1" step="0.1" style="width: 80px;" />
      <span class="status-display" id="zoomDisplay">1.0x</span>
    </div>
    
    <div class="control-group">
      <span class="status-display" id="countDisplay">Transactions: 0</span>
    </div>
  </div>
  
  <!-- Info Panel -->
  <div class="info-panel" id="zoomInfo">
    <strong>Galaxy View</strong><br>
    Each pixel represents a transaction. Zoom in for more details.
  </div>
  
  <!-- Canvas -->
  <canvas id="canvas"></canvas>
  
  <!-- Details Panel -->
  <div id="detailsPanel" class="panel details-panel">
    <h3>Transaction Details</h3>
    <p><strong>ID:</strong> <span id="detailId"></span></p>
    <p><strong>From:</strong> <span id="detailFrom" style="color: var(--source-color);"></span></p>
    <p><strong>To:</strong> <span id="detailTo" style="color: var(--dest-color);"></span></p>
    <p><strong>Amount:</strong> <span id="detailAmount" style="color: var(--rung-color); font-weight: bold;"></span></p>
    <p><strong>Description:</strong> <span id="detailDesc"></span></p>
    <p><strong>Status:</strong> <span id="detailStatus"></span></p>
    <p><strong>Timestamp:</strong> <span id="detailTs"></span></p>
    <div id="historyActions" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--glass-border);">
      <button onclick="moveTransaction()" class="btn btn-small">📋 Move</button>
      <button onclick="deleteTransaction()" class="btn btn-small" style="margin: 0 0.5rem;">❌ Delete</button>
      <button onclick="forkFromHere()" class="btn btn-small">🔀 Fork Here</button>
    </div>
  </div>
  
  <!-- Replace the existing Wallet Panel with this updated version -->
  <div id="walletPanel" class="panel wallet-panel">
    <h3>💳 DirectLedger Wallet</h3>
    <div class="wallet-balance">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Wallet ID</div>
      <div id="walletId" style="font-family: monospace; word-break: break-all; font-weight: bold; font-size: 0.9rem;">DL-XXXX-XXXX-XXXX</div>
    </div>
    <div class="wallet-balance">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Available Balance</div>
      <div id="walletPanelBalance" class="balance-amount">$0.00</div>
    </div>
    <div class="wallet-balance" style="margin-top: 1rem;">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Gold Holdings</div>
      <div id="goldBalance" style="font-weight: bold; color: #FFD700;">0.0000 Au ($0.00)</div>
    </div>
    <div class="wallet-balance" style="margin-top: 1rem;">
      <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0.5rem;">Silver Holdings</div>
      <div id="silverBalance" style="font-weight: bold; color: #C0C0C0;">0.0000 Ag ($0.00)</div>
    </div>
    <div style="margin-bottom: 1rem;">
      <h4 style="margin: 1rem 0 0.5rem 0; color: var(--payment-color);">Recent Payments</h4>
      <div id="recentPayments" style="max-height: 200px; overflow-y: auto; background: var(--glass-bg); border-radius: 12px; padding: 0.5rem;">
        <p style="opacity: 0.6; text-align: center; margin: 1rem;">No payments yet</p>
      </div>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button onclick="openPaymentModal()" class="btn btn-payment" style="flex: 1;">Send Money</button>
      <button onclick="addFunds()" class="btn btn-success" style="flex: 1;">Add Funds</button>
    </div>
  </div>
  

  <!-- Commodity panel -->
<div id="commodityPanel" class="panel commodity-panel">
  <h3>🪙 Commodity Trading</h3>
  <div class="commodity-prices">
    <div id="goldPrice" style="margin: 10px 0; font-weight: bold;">Gold: $0.00/oz</div>
    <div id="silverPrice" style="margin: 10px 0; font-weight: bold;">Silver: $0.00/oz</div>
  </div>
  <div class="commodity-actions">
    <div style="margin-top: 15px;">
      <button id="buyGoldButton" class="btn">Buy Gold</button>
      <button id="sellGoldButton" class="btn">Sell Gold</button>
    </div>
    <div style="margin-top: 10px;">
      <button id="buySilverButton" class="btn">Buy Silver</button>
      <button id="sellSilverButton" class="btn">Sell Silver</button>
    </div>
  </div>
</div>
  
  <!-- Analytics Panel -->
  <div id="analyticsPanel" class="panel analytics-panel">
    <h3>📊 Real-time Analytics</h3>
    <div class="chart-container">
      <div class="chart-title">Transaction Rate</div>
      <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-color);" id="txRate">0 tx/min</div>
    </div>
    <div class="chart-container">
      <div class="chart-title">Total Volume</div>
      <div style="font-size: 1.3rem; font-weight: bold; color: var(--payment-color);" id="totalVolume">$0.00</div>
    </div>
    <div class="chart-container">
      <div class="chart-title">Network Health</div>
      <div style="display: flex; align-items: center; gap: 0.5rem;">
        <div id="networkHealth" style="width: 12px; height: 12px; border-radius: 50%; background: var(--success-color);"></div>
        <span id="networkStatus">Healthy</span>
      </div>
    </div>
    <div class="chart-container">
      <div class="chart-title">Active Wallets</div>
      <div style="font-size: 1.1rem; font-weight: bold;" id="activeWallets">0</div>
    </div>
  </div>
  
  <!-- Notification Container -->
  <div id="notification" class="notification"></div>
  
  <script>
    /**
     * Enhanced Scalable Temporal Blockchain Ledger
     * High-performance visualization with advanced features
     * Now with Gold and Silver backing
     * 
     * @version 3.0.0
     * @author Enhanced by Claude
     * @license MIT
     */
    'use strict';
    // ======================
    // Enhanced State Management
    // ======================
    class LedgerState {
      constructor() {
        this.transactions = [];
        this.blocks = [];
        this.userWallet = {
          id: '',
          balance: 0,
          transactions: [],
          commodityBalances: {
            gold: 0,    // Balance in gold tokens
            silver: 0   // Balance in silver tokens
          }
        };
        this.currentQRCode = {
          recipient: '',
          amount: 0,
          note: '',
          timestamp: null
        };
        this.ui = {
          zoom: 1.0,
          dragOffset: { x: 0, y: 0 },
          dragging: false,
          lastMousePos: { x: 0, y: 0 },
          hoveredBlockIndex: -1,
          selectedTxId: null,
          searchQuery: '',
          filterType: 'all',
          historyMode: false,
          needsRedraw: true,
          animationFrameId: null,
          isAuthenticated: false,
          darkTheme: true,
          isShuttingDown: false
        };
        this.performance = {
          fps: 60,
          frameCount: 0,
          lastFpsUpdate: Date.now(),
          renderTime: 0,
          blockPool: []
        };
        this.analytics = {
          txRate: 0,
          totalVolume: 0,
          activeWallets: new Set(),
          networkHealth: 'healthy'
        };
        this.commodities = {
          gold: {
            name: "Gold",
            symbol: "Au",
            totalReserve: 1000,      // Total ounces in reserve
            pricePerOunce: 1800,     // Current market price in fiat
            tokensInCirculation: 0,  // Number of tokens backed by gold
            reserveRatio: 1.0        // 100% backed
          },
          silver: {
            name: "Silver",
            symbol: "Ag",
            totalReserve: 10000,     // Total ounces in reserve
            pricePerOunce: 25,       // Current market price in fiat
            tokensInCirculation: 0,  // Number of tokens backed by silver
            reserveRatio: 1.0        // 100% backed
          }
        };
      }
    }
    const state = new LedgerState();
    // ======================
    // Commodity Manager
    // ======================
    class CommodityManager {
      static fiatToCommodity(amount, commodityType) {
        const commodity = state.commodities[commodityType];
        if (!commodity) return 0;
        
        const tokenValue = amount / commodity.pricePerOunce;
        
        if (tokenValue > commodity.totalReserve - commodity.tokensInCirculation) {
          return 0; // Not enough reserve
        }
        
        return tokenValue;
      }
      
      static commodityToFiat(tokenAmount, commodityType) {
        const commodity = state.commodities[commodityType];
        if (!commodity) return 0;
        
        return tokenAmount * commodity.pricePerOunce;
      }
      
      static updatePrices() {
        state.commodities.gold.pricePerOunce *= (0.99 + Math.random() * 0.02);
        state.commodities.silver.pricePerOunce *= (0.99 + Math.random() * 0.02);
        
        this.updateCommodityUI();
      }
      
      static updateCommodityUI() {
        const goldPriceEl = document.getElementById('goldPrice');
        const silverPriceEl = document.getElementById('silverPrice');
        
        if (goldPriceEl) {
          goldPriceEl.textContent = `Gold: ${Utils.formatCurrency(state.commodities.gold.pricePerOunce)}/oz`;
        }
        
        if (silverPriceEl) {
          silverPriceEl.textContent = `Silver: ${Utils.formatCurrency(state.commodities.silver.pricePerOunce)}/oz`;
        }
      }
      
      static buyCommodityTokens(amount, commodityType) {
        if (!state.ui.isAuthenticated) return false;
        
        const tokenAmount = this.fiatToCommodity(amount, commodityType);
        if (tokenAmount <= 0) {
          NotificationManager.show('Insufficient reserve for this purchase!', 'error');
          return false;
        }
        
        if (state.userWallet.balance < amount) {
          NotificationManager.show('Insufficient fiat balance!', 'error');
          return false;
        }
        
        state.userWallet.balance -= amount;
        state.userWallet.commodityBalances[commodityType] += tokenAmount;
        
        state.commodities[commodityType].tokensInCirculation += tokenAmount;
        
        const txData = {
          id: Utils.generateId('BUY'),
          from: 'SYSTEM',
          to: state.userWallet.id,
          amount: tokenAmount,
          asset: commodityType,
          fiatValue: amount,
          description: `Purchased ${tokenAmount.toFixed(4)} ${commodityType} tokens`,
          timestamp: new Date().toISOString(),
          type: 'commodity_purchase',
          status: 'completed'
        };
        
        TransactionManager.addTransaction(txData);
        WalletManager.updateUI();
        NotificationManager.show(`Purchased ${tokenAmount.toFixed(4)} ${commodityType} tokens!`, 'success');
        
        return true;
      }
      
      static sellCommodityTokens(tokenAmount, commodityType) {
        if (!state.ui.isAuthenticated) return false;
        
        if (state.userWallet.commodityBalances[commodityType] < tokenAmount) {
          NotificationManager.show('Insufficient commodity tokens!', 'error');
          return false;
        }
        
        const fiatValue = this.commodityToFiat(tokenAmount, commodityType);
        
        state.userWallet.balance += fiatValue;
        state.userWallet.commodityBalances[commodityType] -= tokenAmount;
        
        state.commodities[commodityType].tokensInCirculation -= tokenAmount;
        
        const txData = {
          id: Utils.generateId('SELL'),
          from: state.userWallet.id,
          to: 'SYSTEM',
          amount: tokenAmount,
          asset: commodityType,
          fiatValue: fiatValue,
          description: `Sold ${tokenAmount.toFixed(4)} ${commodityType} tokens`,
          timestamp: new Date().toISOString(),
          type: 'commodity_sale',
          status: 'completed'
        };
        
        TransactionManager.addTransaction(txData);
        WalletManager.updateUI();
        NotificationManager.show(`Sold ${tokenAmount.toFixed(4)} ${commodityType} tokens for ${Utils.formatCurrency(fiatValue)}!`, 'success');
        
        return true;
      }
    }
    // ======================
    // Enhanced Performance Monitoring
    // ======================
    
    class PerformanceMonitor {
      constructor() {
        this.frameStart = 0;
        this.frameEnd = 0;
        this.fpsHistory = [];
        this.renderTimeHistory = [];
      }
      
      startFrame() {
        this.frameStart = performance.now();
      }
      
      endFrame() {
        this.frameEnd = performance.now();
        const renderTime = this.frameEnd - this.frameStart;
        
        // Update FPS
        state.performance.frameCount++;
        const now = Date.now();
        if (now - state.performance.lastFpsUpdate >= 1000) {
          state.performance.fps = state.performance.frameCount;
          state.performance.frameCount = 0;
          state.performance.lastFpsUpdate = now;
          this.updateFPSDisplay();
        }
        
        // Track render time
        this.renderTimeHistory.push(renderTime);
        if (this.renderTimeHistory.length > 60) {
          this.renderTimeHistory.shift();
        }
        
        state.performance.renderTime = renderTime;
      }
      
      updateFPSDisplay() {
        const fpsElement = document.getElementById('fpsCounter');
        const blockElement = document.getElementById('blockCounter');
        
        if (fpsElement) {
          fpsElement.textContent = state.performance.fps;
          fpsElement.style.color = state.performance.fps > 50 ? 'var(--success-color)' : 
                                   state.performance.fps > 30 ? 'var(--warning-color)' : 'var(--error-color)';
        }
        
        if (blockElement) {
          blockElement.textContent = state.blocks.length.toLocaleString();
        }
      }
      
      getAverageRenderTime() {
        if (this.renderTimeHistory.length === 0) return 0;
        return this.renderTimeHistory.reduce((a, b) => a + b, 0) / this.renderTimeHistory.length;
      }
    }
    
    const perfMonitor = new PerformanceMonitor();
    
      // ======================
    // Enhanced DOM Management
    // ======================
           const DOM = {
          // Authentication
          pinModal: document.getElementById('pinModal'),
          pinInput: document.getElementById('pinInput'),
          pinSubmit: document.getElementById('pinSubmit'),
          pinMessage: document.getElementById('pinMessage'),
          // Shutdown
          shutdownModal: document.getElementById('shutdownModal'),
          shutdownButton: document.getElementById('shutdownButton'),
          cancelShutdown: document.getElementById('cancelShutdown'),
          confirmShutdown: document.getElementById('confirmShutdown'),
          // Modals
          txModal: document.getElementById('txModal'),
          paymentModal: document.getElementById('paymentModal'),
          qrcodeModal: document.getElementById('qrcodeModal'),
          scanModal: document.getElementById('scanModal'),
          analyticsModal: document.getElementById('analyticsModal'),
          // Canvas and main UI
          canvas: document.getElementById('canvas'),
          ctx: document.getElementById('canvas')?.getContext('2d'),
          // Controls
          controls: document.getElementById('controls'),
          searchBox: document.getElementById('searchBox'),
          filterSelect: document.getElementById('filterSelect'),
          zoomSlider: document.getElementById('zoomSlider'),
          zoomDisplay: document.getElementById('zoomDisplay'),
          countDisplay: document.getElementById('countDisplay'),
          // Panels
          detailsPanel: document.getElementById('detailsPanel'),
          walletPanel: document.getElementById('walletPanel'),
          analyticsPanel: document.getElementById('analyticsPanel'),
          commodityPanel: document.getElementById('commodityPanel'),
    
          // Commodity
          goldPrice: document.getElementById('goldPrice'),
          silverPrice: document.getElementById('silverPrice'),
          goldBalance: document.getElementById('goldBalance'),
          silverBalance: document.getElementById('silverBalance'),
          // Notification
          notification: document.getElementById('notification'),
          // Theme
          themeToggle: document.getElementById('themeToggle'),
          // Zoom info (FIXED: Added missing element)
          zoomInfo: document.getElementById('zoomInfo')
        };
    // ======================
    // Enhanced Utility Functions
    // ======================
    
    class Utils {
      static formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD'
        }).format(amount);
      }
      
      static formatDate(dateString) {
        return new Intl.DateTimeFormat('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        }).format(new Date(dateString));
      }
      
      static generateId(prefix = 'TXN') {
        return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      }
      
      static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      static throttle(func, limit) {
        let inThrottle;
        return function() {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
      
      static lerp(start, end, factor) {
        return start + (end - start) * factor;
      }
      
      static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
    }
    
    // ======================
    // Enhanced Authentication System
    // ======================
    
    
class AuthenticationManager {
  constructor() {
    this.maxAttempts = 3;
    this.attempts = 0;
    this.lockoutTime = 5 * 60 * 1000; // 5 minutes
  }
  async checkPin() {
    const savedPin = localStorage.getItem('ledgerPin');
    const lockout = localStorage.getItem('ledgerLockout');
    // Check if locked out
    if (lockout && Date.now() < parseInt(lockout)) {
      const remainingTime = Math.ceil((parseInt(lockout) - Date.now()) / 1000 / 60);
      DOM.pinMessage.textContent = `Account locked. Try again in ${remainingTime} minutes.`;
      DOM.pinSubmit.disabled = true;
      return;
    }
    if (savedPin) {
      DOM.pinMessage.textContent = 'Enter your PIN to access the ledger';
      DOM.pinSubmit.textContent = 'Access Ledger';
    } else {
      DOM.pinMessage.textContent = 'Set a 4-digit PIN to secure your ledger';
      DOM.pinSubmit.textContent = 'Set PIN';
    }
    DOM.pinModal.style.display = 'flex';
    DOM.pinInput.focus();
  }
  async validatePin(pin) {
    if (pin.length !== 4 || !/^\d{4}$/.test(pin)) {
      this.showMessage('PIN must be exactly 4 digits');
      return false;
    }
    const savedPin = localStorage.getItem('ledgerPin');
    if (!savedPin) {
      // Set new PIN
      localStorage.setItem('ledgerPin', pin);
      this.showMessage('PIN set successfully!', 'success');
      state.ui.isAuthenticated = true;
      this.closeModal();
      await this.initializeApplication();
      return true;
    } else if (pin === savedPin) {
      // Correct PIN
      this.showMessage('Access granted!', 'success');
      state.ui.isAuthenticated = true;
      this.attempts = 0;
      localStorage.removeItem('ledgerLockout');
      this.closeModal();
      await this.initializeApplication();
      return true;
    } else {
      // Incorrect PIN
      this.attempts++;
      if (this.attempts >= this.maxAttempts) {
        localStorage.setItem('ledgerLockout', (Date.now() + this.lockoutTime).toString());
        this.showMessage('Too many failed attempts. Account locked for 5 minutes.', 'error');
        DOM.pinSubmit.disabled = true;
      } else {
        this.showMessage(`Incorrect PIN. ${this.maxAttempts - this.attempts} attempts remaining.`, 'error');
      }
      DOM.pinInput.value = '';
      return false;
    }
  }
  showMessage(message, type = 'warning') {
    DOM.pinMessage.textContent = message;
    DOM.pinMessage.style.color = `var(--${type}-color)`;
  }
  closeModal() {
    DOM.pinModal.style.display = 'none';
    DOM.pinInput.value = '';
    DOM.pinMessage.textContent = '';
  }
  async initializeApplication() {
    try {
      await CanvasManager.resizeCanvas();
      RenderEngine.updateZoomInfo();
      await WalletManager.initialize();
      await AnalyticsManager.initialize();
      // Show welcome message
      NotificationManager.show('Welcome to Enhanced Blockchain Ledger!', 'success');
      // Auto-generate demo data
      setTimeout(() => {
        TransactionManager.generateGalaxy(250);
      }, 1000);
    } catch (error) {
      console.error('Error initializing application:', error);
      NotificationManager.show('Error initializing application. Please refresh.', 'error');
    }
  }
}
// Instantiate only once
const authManager = new AuthenticationManager();
    // ======================
    // Enhanced Canvas Management
    // ======================
    
    class CanvasManager {
      static async resizeCanvas() {
        if (!state.ui.isAuthenticated) return;
        
        const controlsHeight = DOM.controls?.offsetHeight || 0;
        DOM.canvas.width = window.innerWidth;
        DOM.canvas.height = window.innerHeight - controlsHeight;
        DOM.canvas.style.marginTop = `${controlsHeight}px`;
        
        // Enable high DPI rendering
        const devicePixelRatio = window.devicePixelRatio || 1;
        const rect = DOM.canvas.getBoundingClientRect();
        
        DOM.canvas.width = rect.width * devicePixelRatio;
        DOM.canvas.height = rect.height * devicePixelRatio;
        DOM.canvas.style.width = rect.width + 'px';
        DOM.canvas.style.height = rect.height + 'px';
        
        DOM.ctx.scale(devicePixelRatio, devicePixelRatio);
        
        this.centerView();
        RenderEngine.requestDraw();
      }
      
      static centerView() {
        if (!state.ui.isAuthenticated || state.blocks.length === 0) return;
        
        const blockSize = 40 * state.ui.zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        const cols = Math.max(1, Math.floor(DOM.canvas.width / (hexWidth * 0.75)));
        const rows = Math.ceil(state.blocks.length / cols);
        const layoutWidth = cols * hexWidth * 0.75;
        const layoutHeight = rows * hexHeight;
        
        state.ui.dragOffset.x = (DOM.canvas.width - layoutWidth) / 2;
        state.ui.dragOffset.y = (DOM.canvas.height - layoutHeight) / 2;
      }
    }
    
    // ======================
    // Enhanced Render Engine
    // ======================
    
    class RenderEngine {
      static PIXEL_THRESHOLD = 0.3;
      static SIMPLE_THRESHOLD = 0.8;
      static colors = {
        source: '#3498db',
        dest: '#2ecc71',
        payment: '#16a085',
        qrcode: '#2c3e50',
        connection: '#e74c3c',
        highlight: '#f1c40f'
      };
      
      static requestDraw() {
        state.ui.needsRedraw = true;
      }
      
      static animate() {
        if (state.ui.needsRedraw) {
          perfMonitor.startFrame();
          this.draw();
          state.ui.needsRedraw = false;
          perfMonitor.endFrame();
        }
        state.ui.animationFrameId = requestAnimationFrame(() => this.animate());
      }
      
      static draw() {
        if (!state.ui.isAuthenticated || !DOM.ctx) return;
        
        DOM.ctx.clearRect(0, 0, DOM.canvas.width, DOM.canvas.height);
        
        if (state.blocks.length === 0) {
          this.drawEmptyState();
          return;
        }
        
        // Apply theme
        this.applyTheme();
        
        if (state.ui.zoom < this.PIXEL_THRESHOLD) {
          this.drawGalaxyView();
        } else if (state.ui.zoom < this.SIMPLE_THRESHOLD) {
          this.drawClusterView();
        } else {
          this.drawBlockView();
        }
        
        // Draw overlay effects
        this.drawOverlayEffects();
      }
      
      static applyTheme() {
        if (!state.ui.darkTheme) {
          // Light theme adjustments
          this.colors.source = '#2980b9';
          this.colors.dest = '#27ae60';
          this.colors.payment = '#138d75';
          DOM.ctx.globalCompositeOperation = 'source-over';
        } else {
          // Dark theme (default)
          this.colors.source = '#3498db';
          this.colors.dest = '#2ecc71';
          this.colors.payment = '#16a085';
        }
      }
      
      static drawEmptyState() {
        DOM.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        DOM.ctx.font = '24px Inter, sans-serif';
        DOM.ctx.textAlign = 'center';
        DOM.ctx.textBaseline = 'middle';
        DOM.ctx.fillText(
          'No transactions yet. Click "Add Transaction" or "Generate Galaxy" to start!',
          DOM.canvas.width / 2,
          DOM.canvas.height / 2
        );
      }
      
      static drawGalaxyView() {
        const cols = Math.max(1, Math.floor(DOM.canvas.width / 3));
        const spacing = 3;
        
        DOM.ctx.imageSmoothingEnabled = false;
        
        // Optimized viewport culling
        const viewportBuffer = 50;
        const startIdx = Math.max(0, Math.floor((-state.ui.dragOffset.y - viewportBuffer) / spacing) * cols);
        const endIdx = Math.min(state.blocks.length, 
          Math.ceil((DOM.canvas.height - state.ui.dragOffset.y + viewportBuffer) / spacing) * cols);
        
        // Batch render pixels for better performance
        const imageData = DOM.ctx.createImageData(DOM.canvas.width, DOM.canvas.height);
        const data = imageData.data;
        
        for (let index = startIdx; index < endIdx; index++) {
          const block = state.blocks[index];
          if (!this.passesFilter(block)) continue;
          
          const col = index % cols;
          const row = Math.floor(index / cols);
          const x = Math.floor(col * spacing + state.ui.dragOffset.x + DOM.canvas.width / 4);
          const y = Math.floor(row * spacing + state.ui.dragOffset.y + DOM.canvas.height / 4);
          
          if (x < 0 || x >= DOM.canvas.width || y < 0 || y >= DOM.canvas.height) continue;
          
          const isSearched = this.isSearchMatch(block);
          const alpha = (state.ui.searchQuery && !isSearched) ? 25 : 255;
          
          const pixelIndex = (y * DOM.canvas.width + x) * 4;
          const color = this.getBlockColor(block);
          const rgb = this.hexToRgb(color);
          
          data[pixelIndex] = rgb.r;     // Red
          data[pixelIndex + 1] = rgb.g; // Green
          data[pixelIndex + 2] = rgb.b; // Blue
          data[pixelIndex + 3] = alpha; // Alpha
        }
        
        DOM.ctx.putImageData(imageData, 0, 0);
        DOM.ctx.imageSmoothingEnabled = true;
      }
      
      static drawClusterView() {
        const blockSize = 25 * state.ui.zoom;
        const hexWidth = blockSize * 1.8;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Draw connections with improved styling
        this.drawConnections(hexWidth, hexHeight, 1.5 * state.ui.zoom);
        
        // Draw simplified hexagons with better performance
        const visibleBlocks = this.getVisibleBlocks(hexWidth, hexHeight);
        
        for (const { block, index, pos } of visibleBlocks) {
          if (!this.passesFilter(block)) continue;
          
          const isSearched = this.isSearchMatch(block);
          DOM.ctx.globalAlpha = (state.ui.searchQuery && !isSearched) ? 0.3 : 1.0;
          
          this.drawSimpleHexagon(pos.x, pos.y, blockSize, this.getBlockColor(block));
        }
        
        DOM.ctx.globalAlpha = 1.0;
      }
      
      static drawBlockView() {
        const blockSize = 40 * state.ui.zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Draw enhanced connections
        this.drawConnections(hexWidth, hexHeight, 3 * state.ui.zoom);
        
        // Draw detailed blocks
        const visibleBlocks = this.getVisibleBlocks(hexWidth, hexHeight);
        
        for (const { block, index, pos } of visibleBlocks) {
          if (!this.passesFilter(block)) continue;
          this.drawDetailedHexBlock(block, pos.x, pos.y, index, blockSize);
        }
      }
      
      static drawConnections(hexWidth, hexHeight, lineWidth) {
        DOM.ctx.strokeStyle = this.colors.connection;
        DOM.ctx.lineWidth = lineWidth;
        DOM.ctx.lineCap = 'round';
        
        for (let i = 0; i < state.transactions.length; i++) {
          const tx = state.transactions[i];
          const sourceIndex = state.blocks.findIndex(b => b.txId === tx.id && b.type === 'source');
          const destIndex = state.blocks.findIndex(b => b.txId === tx.id && b.type === 'destination');
          
          if (sourceIndex === -1 || destIndex === -1) continue;
          
          const posA = this.getBlockPosition(sourceIndex, hexWidth, hexHeight);
          const posB = this.getBlockPosition(destIndex, hexWidth, hexHeight);
          
          // Viewport culling for connections
          if (!this.isConnectionVisible(posA, posB)) continue;
          
          const isHovered = state.ui.hoveredBlockIndex !== -1 && 
            state.blocks[state.ui.hoveredBlockIndex].txId === tx.id;
          const isSelected = state.ui.selectedTxId === tx.id;
          const isSearched = this.isTransactionSearchMatch(tx);
          
          DOM.ctx.globalAlpha = (state.ui.searchQuery && !isSearched) ? 0.2 : 1.0;
          
          // Enhanced connection styling
          if (isHovered || isSelected) {
            DOM.ctx.strokeStyle = this.colors.highlight;
            DOM.ctx.lineWidth = lineWidth * 1.5;
            DOM.ctx.shadowColor = this.colors.highlight;
            DOM.ctx.shadowBlur = 10;
          } else if (tx.type === 'payment') {
            DOM.ctx.strokeStyle = tx.paymentType === 'qrcode' ? this.colors.qrcode : this.colors.payment;
          } else {
            DOM.ctx.strokeStyle = this.colors.connection;
          }
          
          DOM.ctx.beginPath();
          DOM.ctx.moveTo(posA.x, posA.y);
          DOM.ctx.lineTo(posB.x, posB.y);
          DOM.ctx.stroke();
          
          // Reset effects
          DOM.ctx.shadowBlur = 0;
          DOM.ctx.strokeStyle = this.colors.connection;
          DOM.ctx.lineWidth = lineWidth;
        }
        
        DOM.ctx.globalAlpha = 1.0;
      }
      
      static drawDetailedHexBlock(block, x, y, index, blockSize) {
        const isHovered = state.ui.hoveredBlockIndex !== -1 && 
          state.blocks[state.ui.hoveredBlockIndex].txId === block.txId;
        const isSelected = state.ui.selectedTxId === block.txId;
        const isSearched = this.isSearchMatch(block);
        
        DOM.ctx.save();
        DOM.ctx.globalAlpha = (state.ui.searchQuery && !isSearched) ? 0.2 : 1.0;
        
        // Enhanced visual effects
        if (isHovered || isSelected) {
          DOM.ctx.fillStyle = this.colors.highlight;
          DOM.ctx.shadowColor = this.colors.highlight;
          DOM.ctx.shadowBlur = 15;
        } else {
          DOM.ctx.fillStyle = this.getBlockColor(block);
          if (state.ui.historyMode) {
            DOM.ctx.shadowColor = '#9b59b6';
            DOM.ctx.shadowBlur = 8;
          }
        }
        
        // Draw hexagon with improved geometry
        this.drawHexagon(x, y, blockSize);
        DOM.ctx.fill();
        
        if (isSelected) {
          DOM.ctx.strokeStyle = 'white';
          DOM.ctx.lineWidth = 4;
          DOM.ctx.stroke();
        }
        
        // Draw enhanced text labels
        if (state.ui.zoom > 0.6) {
          this.drawBlockText(block, x, y, blockSize, isHovered || isSelected);
        }
        
        DOM.ctx.restore();
      }
      
      static drawHexagon(x, y, size) {
        DOM.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i;
          const px = x + size * Math.cos(angle);
          const py = y + size * Math.sin(angle);
          i === 0 ? DOM.ctx.moveTo(px, py) : DOM.ctx.lineTo(px, py);
        }
        DOM.ctx.closePath();
      }
      
      static drawSimpleHexagon(x, y, size, color) {
        DOM.ctx.fillStyle = color;
        this.drawHexagon(x, y, size);
        DOM.ctx.fill();
      }
      
      static drawBlockText(block, x, y, blockSize, isHighlighted) {
        DOM.ctx.fillStyle = isHighlighted ? '#000' : '#fff';
        DOM.ctx.textAlign = 'center';
        DOM.ctx.textBaseline = 'middle';
        DOM.ctx.font = `bold ${Math.max(8, blockSize * 0.12)}px Inter, sans-serif`;
        
        let label = block.type === 'source' ? 'FROM' : 'TO';
        if (block.data.type === 'payment') {
          label = block.type === 'source' ? 'PAYER' : 'PAYEE';
          if (block.data.paymentType === 'qrcode') {
            label = '📱 ' + label;
          }
        }
        
        // Draw label
        DOM.ctx.fillText(label, x, y - blockSize * 0.3);
        
        // Draw identifier
        DOM.ctx.font = `${Math.max(7, blockSize * 0.1)}px Inter, sans-serif`;
        let displayText = block.type === 'source' ? block.data.from : block.data.to;
        if (displayText.length > 8) {
          displayText = displayText.substring(0, 8) + '…';
        }
        DOM.ctx.fillText(displayText, x, y);
        
        // Draw additional info for high zoom
        if (state.ui.zoom > 1.5) {
          DOM.ctx.fillText(`ID: ${block.data.id.slice(-4)}`, x, y + blockSize * 0.3);
        }
      }
      
      static drawOverlayEffects() {
        // Draw selection highlights, animations, etc.
        if (state.ui.hoveredBlockIndex !== -1) {
          // Add subtle glow effect for hovered items
          const block = state.blocks[state.ui.hoveredBlockIndex];
          // Additional hover effects can be implemented here
        }
      }
      
      // Utility methods
      static getVisibleBlocks(hexWidth, hexHeight) {
        const visible = [];
        const buffer = 100;
        
        for (let i = 0; i < state.blocks.length; i++) {
          const pos = this.getBlockPosition(i, hexWidth, hexHeight);
          if (pos.x > -buffer && pos.x < DOM.canvas.width + buffer &&
              pos.y > -buffer && pos.y < DOM.canvas.height + buffer) {
            visible.push({ block: state.blocks[i], index: i, pos });
          }
        }
        
        return visible;
      }
      
      static getBlockPosition(index, hexWidth, hexHeight) {
        const cols = Math.max(1, Math.floor(DOM.canvas.width / (hexWidth * 0.75)));
        const col = index % cols;
        const row = Math.floor(index / cols);
        
        const layoutWidth = cols * hexWidth * 0.75;
        const layoutHeight = Math.ceil(state.blocks.length / cols) * hexHeight;
        const centerOffsetX = DOM.canvas.width / 2 - layoutWidth / 2;
        const centerOffsetY = DOM.canvas.height / 2 - layoutHeight / 2;
        
        const x = col * hexWidth * 0.75 + state.ui.dragOffset.x + centerOffsetX;
        const y = row * hexHeight + (col % 2 === 0 ? 0 : hexHeight / 2) + state.ui.dragOffset.y + centerOffsetY;
        return { x, y };
      }
      
      static isConnectionVisible(posA, posB) {
        const buffer = 50;
        return !((posA.x < -buffer && posB.x < -buffer) || 
                (posA.x > DOM.canvas.width + buffer && posB.x > DOM.canvas.width + buffer) ||
                (posA.y < -buffer && posB.y < -buffer) || 
                (posA.y > DOM.canvas.height + buffer && posB.y > DOM.canvas.height + buffer));
      }
      
      static passesFilter(block) {
        if (state.ui.filterType === 'all') return true;
        if (state.ui.filterType === 'payment' && block.data.type !== 'payment') return false;
        if (state.ui.filterType === 'qrcode' && block.data.paymentType !== 'qrcode') return false;
        if (state.ui.filterType !== 'payment' && state.ui.filterType !== 'qrcode' && block.type !== state.ui.filterType) return false;
        return true;
      }
      
      static isSearchMatch(block) {
        if (!state.ui.searchQuery) return true;
        const query = state.ui.searchQuery.toLowerCase();
        return block.data.id.toLowerCase().includes(query) ||
               block.data.from.toLowerCase().includes(query) ||
               block.data.to.toLowerCase().includes(query) ||
               block.data.description?.toLowerCase().includes(query);
      }
      
      static isTransactionSearchMatch(tx) {
        if (!state.ui.searchQuery) return true;
        const query = state.ui.searchQuery.toLowerCase();
        return tx.id.toLowerCase().includes(query) ||
               tx.from.toLowerCase().includes(query) ||
               tx.to.toLowerCase().includes(query) ||
               tx.description?.toLowerCase().includes(query);
      }
      
      static getBlockColor(block) {
        if (block.data.type === 'payment') {
          return block.data.paymentType === 'qrcode' ? this.colors.qrcode : this.colors.payment;
        }
        return block.type === 'source' ? this.colors.source : this.colors.dest;
      }
      
      static hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 255, g: 255, b: 255 };
      }
      
      static updateZoomInfo() {
        const info = DOM.zoomInfo;
        if (!info) return;
        
        if (state.ui.zoom < this.PIXEL_THRESHOLD) {
          info.innerHTML = '<strong>🌌 Galaxy View</strong><br>Each pixel represents a transaction. Zoom in for details.';
        } else if (state.ui.zoom < this.SIMPLE_THRESHOLD) {
          info.innerHTML = '<strong>🔍 Cluster View</strong><br>Simplified hexagons showing transaction structure.';
        } else {
          info.innerHTML = '<strong>📋 Detail View</strong><br>Full transaction details and interactions.';
        }
      }
    }
    
  // ======================
    // Enhanced Transaction Management
    // ======================
    class TransactionManager {
      static generateGalaxy(count = 1000) {
        if (!state.ui.isAuthenticated) return;
        
        const names = [
          "Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Heidi", 
          "Ivan", "Judy", "Kevin", "Luna", "Mike", "Nina", "Oscar", "Penny",
          "Quinn", "Rachel", "Steve", "Tina", "Uma", "Victor", "Wendy", "Xander"
        ];
        
        const items = [
          "Smart Contract Execution", "DeFi Token Swap", "NFT Marketplace Trade",
          "Cross-chain Bridge", "Governance Voting", "Staking Rewards", "Liquidity Mining",
          "Oracle Data Feed", "Layer 2 Settlement", "Privacy Transaction", "DAO Proposal",
          "Yield Farming", "Flash Loan", "Arbitrage Trade", "Insurance Claim"
        ];
        
        NotificationManager.show(`Generating ${count.toLocaleString()} transactions...`, 'default');
        
        const batchSize = 500;
        let processed = 0;
        
        const processBatch = () => {
          try {
            const end = Math.min(processed + batchSize, count);
            const newTransactions = [];
            const newBlocks = [];
            
            for (let i = processed; i < end; i++) {
              const from = names[Math.floor(Math.random() * names.length)];
              let to;
              do { to = names[Math.floor(Math.random() * names.length)]; } while (from === to);
              
              const isCommodity = Math.random() > 0.9;
              const commodityType = isCommodity ? (Math.random() > 0.5 ? 'gold' : 'silver') : null;
              const amount = isCommodity ? 
                (Math.random() * 10).toFixed(4) : // Smaller amounts for commodities
                (Math.random() * 5000 + 10).toFixed(2);
              const description = items[Math.floor(Math.random() * items.length)];
              const timestamp = new Date(Date.now() - (count - i) * 30000).toISOString();
              
              const isPayment = Math.random() > 0.8;
              const isQRPayment = isPayment && Math.random() > 0.7;
              
              const newTx = {
                id: Utils.generateId(isPayment ? (isQRPayment ? 'QRP' : 'PAY') : isCommodity ? 'COM' : 'TXN'),
                from, to, 
                amount,
                asset: isCommodity ? commodityType : 'fiat',
                fiatValue: isCommodity ? CommodityManager.commodityToFiat(parseFloat(amount), commodityType) : amount,
                description, 
                timestamp,
                type: isPayment ? 'payment' : isCommodity ? 'commodity_transfer' : 'standard',
                paymentType: isQRPayment ? 'qrcode' : 'standard',
                status: 'completed'
              };
              
              newTransactions.push(newTx);
              newBlocks.push({ type: 'source', txId: newTx.id, data: newTx });
              newBlocks.push({ type: 'destination', txId: newTx.id, data: newTx });
              
              state.analytics.activeWallets.add(from);
              state.analytics.activeWallets.add(to);
              state.analytics.totalVolume += parseFloat(newTx.fiatValue || newTx.amount);
            }
            
            state.transactions.push(...newTransactions);
            state.blocks.push(...newBlocks);
            
            processed = end;
            this.updateDisplay();
            AnalyticsManager.updateRealTimeStats();
            
            if (processed < count) {
              requestIdleCallback(processBatch);
            } else {
              NotificationManager.show(`Galaxy generated with ${count.toLocaleString()} transactions!`, 'success');
              CanvasManager.centerView();
            }
          } catch (error) {
            console.error('Error generating galaxy:', error);
            NotificationManager.show('Error generating transactions. Please try again.', 'error');
          }
        };
        
        processBatch();
      }
      
      static addTransaction(txData) {
        if (!state.ui.isAuthenticated) return;
        
        const newTx = txData || {
          id: Utils.generateId(),
          from: "User_" + Math.floor(Math.random() * 1000),
          to: "User_" + Math.floor(Math.random() * 1000),
          amount: (Math.random() * 500 + 10).toFixed(2),
          asset: 'fiat',
          description: "Manual Transaction",
          timestamp: new Date().toISOString(),
          type: 'standard',
          status: 'completed'
        };
        
        state.transactions.push(newTx);
        state.blocks.push({ type: 'source', txId: newTx.id, data: newTx });
        state.blocks.push({ type: 'destination', txId: newTx.id, data: newTx });
        
        state.analytics.activeWallets.add(newTx.from);
        state.analytics.activeWallets.add(newTx.to);
        state.analytics.totalVolume += parseFloat(newTx.fiatValue || newTx.amount);
        
        this.updateDisplay();
        AnalyticsManager.updateRealTimeStats();
      }
      
      static updateDisplay() {
        if (DOM.countDisplay) {
          DOM.countDisplay.textContent = `Transactions: ${state.transactions.length.toLocaleString()}`;
        }
        RenderEngine.requestDraw();
      }
      
      static clearLedger() {
        if (!state.ui.isAuthenticated) return;
        
        state.transactions = [];
        state.blocks = [];
        state.ui.dragOffset = { x: 0, y: 0 };
        state.ui.selectedTxId = null;
        state.analytics.totalVolume = 0;
        state.analytics.activeWallets.clear();
        
        UIManager.hidePanels();
        this.updateDisplay();
        AnalyticsManager.updateRealTimeStats();
      }
      
      static deleteTransaction(txId) {
        const txIndex = state.transactions.findIndex(t => t.id === txId);
        if (txIndex !== -1) {
          const tx = state.transactions[txIndex];
          state.transactions.splice(txIndex, 1);
          state.blocks = state.blocks.filter(b => b.txId !== txId);
          
          state.analytics.totalVolume -= parseFloat(tx.fiatValue || tx.amount);
          
          state.ui.selectedTxId = null;
          UIManager.hidePanel('details');
          this.updateDisplay();
          AnalyticsManager.updateRealTimeStats();
          NotificationManager.show('Transaction deleted from history!', 'warning');
        }
      }
      
      static forkTransaction(txId) {
        const tx = state.transactions.find(t => t.id === txId);
        if (tx) {
          const forkTx = {
            ...tx,
            id: tx.id + '-FORK-' + Date.now(),
            description: tx.description + ' (Timeline Fork)',
            timestamp: new Date().toISOString()
          };
          this.addTransaction(forkTx);
          NotificationManager.show('Timeline forked! Created alternate history branch.', 'success');
        }
      }
    }
    // ======================
    // Enhanced Wallet Management
    // ======================
    class WalletManager {
      static async initialize() {
        try {
          const saved = localStorage.getItem('directLedgerWallet');
          if (saved) {
            state.userWallet = JSON.parse(saved);
            if (!state.userWallet.commodityBalances) {
              state.userWallet.commodityBalances = {
                gold: 0,
                silver: 0
              };
            }
          } else {
            state.userWallet = {
              id: this.generateWalletId(),
              balance: 500.00,
              transactions: [],
              commodityBalances: {
                gold: 0,
                silver: 0
              }
            };
            this.save();
          }
          this.updateUI();
        } catch (error) {
          console.error('Error initializing wallet:', error);
          NotificationManager.show('Error initializing wallet. Using default values.', 'warning');
        }
      }
      
      static generateWalletId() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = 'DL-';
        for (let i = 0; i < 12; i++) {
          if (i > 0 && i % 4 === 0) result += '-';
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }
      
      static save() {
        try {
          localStorage.setItem('directLedgerWallet', JSON.stringify(state.userWallet));
        } catch (error) {
          console.error('Error saving wallet:', error);
          NotificationManager.show('Error saving wallet data.', 'error');
        }
      }
      
      static updateUI() {
        const elements = {
          walletId: document.getElementById('walletId'),
          walletBalance: document.getElementById('walletBalance'),
          walletPanelBalance: document.getElementById('walletPanelBalance'),
          recentPayments: document.getElementById('recentPayments'),
          goldBalance: document.getElementById('goldBalance'),
          silverBalance: document.getElementById('silverBalance')
        };
        
        if (elements.walletId) elements.walletId.textContent = state.userWallet.id;
        if (elements.walletBalance) elements.walletBalance.textContent = Utils.formatCurrency(state.userWallet.balance);
        if (elements.walletPanelBalance) elements.walletPanelBalance.textContent = Utils.formatCurrency(state.userWallet.balance);
        
        if (elements.goldBalance) {
          const goldValue = CommodityManager.commodityToFiat(
            state.userWallet.commodityBalances.gold, 
            'gold'
          );
          elements.goldBalance.textContent = `${state.userWallet.commodityBalances.gold.toFixed(4)} Au (${Utils.formatCurrency(goldValue)})`;
        }
        
        if (elements.silverBalance) {
          const silverValue = CommodityManager.commodityToFiat(
            state.userWallet.commodityBalances.silver, 
            'silver'
          );
          elements.silverBalance.textContent = `${state.userWallet.commodityBalances.silver.toFixed(4)} Ag (${Utils.formatCurrency(silverValue)})`;
        }
        
        CommodityManager.updateCommodityUI();
        
        this.updateRecentPayments(elements.recentPayments);
      }
      
  // In the WalletManager class, replace the updateRecentPayments method with this fixed version:

static updateRecentPayments(container) {
  if (!container) return;
  
  if (state.userWallet.transactions.length === 0) {
    container.innerHTML = '<p style="opacity: 0.6; text-align: center; margin: 1rem;">No payments yet</p>';
    return;
  }
  
  container.innerHTML = '';
  const recent = state.userWallet.transactions.slice(-5).reverse();
  
  recent.forEach(tx => {
    // FIXED: Added null checks for transaction properties
    if (!tx) return;
    
    const isOutgoing = tx.from === state.userWallet.id;
    const txEl = document.createElement('div');
    txEl.className = 'payment-item';
    txEl.style.cssText = `
      padding: 0.75rem;
      border-bottom: 1px solid var(--glass-border);
      border-radius: 8px;
      margin-bottom: 0.5rem;
      background: var(--glass-bg);
      transition: all 0.2s ease;
      cursor: pointer;
    `;
    
    // FIXED: Added null checks and default values
    const amountText = tx.asset === 'fiat' 
      ? Utils.formatCurrency(parseFloat(tx.amount || 0))
      : `${parseFloat(tx.amount || 0).toFixed(4)} ${(tx.asset || 'unknown').toUpperCase()} (${Utils.formatCurrency(tx.fiatValue || 0)})`;
    
    txEl.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <div>
          <div style="font-weight: 600; color: ${isOutgoing ? 'var(--error-color)' : 'var(--success-color)'};">
            ${isOutgoing ? '→' : '←'} ${isOutgoing ? (tx.to || 'unknown').substring(0, 12) + '...' : (tx.from || 'unknown').substring(0, 12) + '...'}
          </div>
          <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 0.2rem;">
            ${tx.timestamp ? Utils.formatDate(tx.timestamp) : 'Unknown date'}
          </div>
        </div>
        <div style="text-align: right;">
          <div style="font-weight: bold; font-size: 1.1rem; color: ${isOutgoing ? 'var(--error-color)' : 'var(--success-color)'};">
            ${isOutgoing ? '-' : '+'}${amountText}
          </div>
          <div class="tx-status tx-status-${tx.status || 'unknown'}" style="margin-top: 0.2rem;">
            ${tx.status || 'unknown'}
          </div>
        </div>
      </div>
    `;
    
    txEl.addEventListener('mouseenter', () => {
      txEl.style.background = 'var(--glass-strong)';
      txEl.style.transform = 'translateX(5px)';
    });
    
    txEl.addEventListener('mouseleave', () => {
      txEl.style.background = 'var(--glass-bg)';
      txEl.style.transform = 'translateX(0)';
    });
    
    container.appendChild(txEl);
  });
}
      
      static processPayment(recipient, amount, note, speed, paymentType = 'standard') {
        const fees = { instant: 0.005, fast: 0.002, standard: 0 };
        const fee = amount * (fees[speed] || 0);
        const totalAmount = amount + fee;
        
        if (state.userWallet.balance < totalAmount) {
          NotificationManager.show('Insufficient balance for this payment!', 'error');
          return false;
        }
        
        const paymentTx = {
          id: Utils.generateId(paymentType === 'qrcode' ? 'QRP' : 'PAY'),
          from: state.userWallet.id,
          to: recipient,
          amount: amount,
          fee: fee,
          description: note || 'DirectLedger Payment',
          timestamp: new Date().toISOString(),
          speed: speed,
          type: 'payment',
          paymentType: paymentType,
          status: 'pending',
          asset: 'fiat'
        };
        
        state.userWallet.balance -= totalAmount;
        state.userWallet.transactions.push(paymentTx);
        
        TransactionManager.addTransaction(paymentTx);
        
        const processingTime = speed === 'instant' ? 500 : speed === 'fast' ? 2000 : 5000;
        
        setTimeout(() => {
          paymentTx.status = 'completed';
          this.save();
          this.updateUI();
          NotificationManager.show(
            `${paymentType === 'qrcode' ? 'QR ' : ''}Payment of ${Utils.formatCurrency(amount)} sent successfully!`, 
            'payment-notification'
          );
        }, processingTime);
        
        this.save();
        this.updateUI();
        return true;
      }
      
      static addFunds(amount) {
        if (!amount || amount <= 0) return false;
        
        state.userWallet.balance += amount;
        state.userWallet.transactions.push({
          id: Utils.generateId('ADD'),
          from: 'SYSTEM',
          to: state.userWallet.id,
          amount: amount,
          description: 'Funds Added',
          timestamp: new Date().toISOString(),
          type: 'add_funds',
          status: 'completed',
          asset: 'fiat'
        });
        
        this.save();
        this.updateUI();
        NotificationManager.show(`Added ${Utils.formatCurrency(amount)} to your wallet!`, 'success');
        return true;
      }
    }
    // ======================
    // Enhanced Analytics Management
    // ======================
    
    class AnalyticsManager {
      static async initialize() {
        try {
          this.updateRealTimeStats();
          this.startRealTimeUpdates();
        } catch (error) {
          console.error('Error initializing analytics:', error);
          NotificationManager.show('Error initializing analytics.', 'warning');
        }
      }
      
      static updateRealTimeStats() {
        const elements = {
          txRate: document.getElementById('txRate'),
          totalVolume: document.getElementById('totalVolume'),
          activeWallets: document.getElementById('activeWallets'),
          networkStatus: document.getElementById('networkStatus'),
          networkHealth: document.getElementById('networkHealth')
        };
        
        // Calculate transaction rate (simplified)
        const recentTx = state.transactions.filter(tx => {
          const age = Date.now() - new Date(tx.timestamp).getTime();
          return age < 60000; // Last minute
        });
        
        state.analytics.txRate = recentTx.length;
        
        // Update UI
        if (elements.txRate) elements.txRate.textContent = `${state.analytics.txRate} tx/min`;
        if (elements.totalVolume) elements.totalVolume.textContent = Utils.formatCurrency(state.analytics.totalVolume);
        if (elements.activeWallets) elements.activeWallets.textContent = state.analytics.activeWallets.size.toLocaleString();
        
        // Network health simulation
        const health = state.analytics.txRate > 50 ? 'congested' : state.analytics.txRate > 20 ? 'busy' : 'healthy';
        const healthColors = { healthy: 'var(--success-color)', busy: 'var(--warning-color)', congested: 'var(--error-color)' };
        
        if (elements.networkHealth) elements.networkHealth.style.background = healthColors[health];
        if (elements.networkStatus) elements.networkStatus.textContent = health.charAt(0).toUpperCase() + health.slice(1);
      }
      
      static startRealTimeUpdates() {
        setInterval(() => {
          this.updateRealTimeStats();
        }, 5000);
      }
      
      static showAnalyticsModal() {
        if (DOM.analyticsModal) {
          DOM.analyticsModal.style.display = 'flex';
          this.renderCharts();
        }
      }
      
      static renderCharts() {
        this.renderVolumeChart();
        this.renderTypeChart();
      }
      
      static renderVolumeChart() {
        const canvas = document.getElementById('volumeChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Simple volume chart visualization
        ctx.fillStyle = 'var(--payment-color)';
        ctx.fillRect(50, 150, 500, 30);
        
        ctx.fillStyle = 'white';
        ctx.font = '14px Inter';
        ctx.fillText('Transaction Volume Over Time', 10, 20);
        ctx.fillText(`Total: ${Utils.formatCurrency(state.analytics.totalVolume)}`, 10, 40);
      }
      
      static renderTypeChart() {
        const canvas = document.getElementById('typeChart');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Simple pie chart for transaction types
        const types = {
          standard: state.transactions.filter(tx => tx.type === 'standard').length,
          payment: state.transactions.filter(tx => tx.type === 'payment' && tx.paymentType !== 'qrcode').length,
          qrcode: state.transactions.filter(tx => tx.paymentType === 'qrcode').length
        };
        
        const total = Object.values(types).reduce((a, b) => a + b, 0);
        let startAngle = 0;
        const colors = ['var(--source-color)', 'var(--payment-color)', 'var(--qrcode-color)'];
        
        Object.entries(types).forEach(([type, count], index) => {
          if (count === 0) return;
          
          const sliceAngle = (count / total) * 2 * Math.PI;
          ctx.fillStyle = colors[index];
          ctx.beginPath();
          ctx.moveTo(150, 100);
          ctx.arc(150, 100, 80, startAngle, startAngle + sliceAngle);
          ctx.closePath();
          ctx.fill();
          
          startAngle += sliceAngle;
        });
        
        ctx.fillStyle = 'white';
        ctx.font = '14px Inter';
        ctx.fillText('Transaction Types Distribution', 10, 20);
      }
    }
    
  class UIManager {
  static showPanel(type) {
    this.hidePanels();
    switch (type) {
      case 'wallet':
        if (DOM.walletPanel) DOM.walletPanel.style.display = 'block';
        WalletManager.updateUI();
        break;
      case 'analytics':
        if (DOM.analyticsPanel) DOM.analyticsPanel.style.display = 'block';
        AnalyticsManager.updateRealTimeStats();
        break;
      case 'details':
        if (DOM.detailsPanel) DOM.detailsPanel.style.display = 'block';
        break;
      case 'commodity':
        console.log('Showing commodity panel');
        if (DOM.commodityPanel) {
          console.log('Setting commodity panel display to block');
          
          // Force visibility with inline styles to ensure it appears
          DOM.commodityPanel.style.cssText = `
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: fixed !important;
            top: 100px !important;
            right: 20px !important;
            width: 300px !important;
            z-index: 1000 !important;
            background: rgba(20, 20, 30, 0.95) !important;
            color: rgb(240, 240, 240) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 12px !important;
            padding: 15px !important;
          `;
          
          CommodityManager.updateCommodityUI();
        } else {
          console.error('Commodity panel not found in DOM object');
        }
        break;
      default:
        console.log('Unknown panel type:', type);
    }
  }
  
  static hidePanel(type) {
    switch (type) {
      case 'wallet':
        if (DOM.walletPanel) DOM.walletPanel.style.display = 'none';
        break;
      case 'analytics':
        if (DOM.analyticsPanel) DOM.analyticsPanel.style.display = 'none';
        break;
      case 'details':
        if (DOM.detailsPanel) DOM.detailsPanel.style.display = 'none';
        break;
      case 'commodity':
        if (DOM.commodityPanel) DOM.commodityPanel.style.display = 'none';
        break;
    }
  }

  static hidePanels() {
    console.log('Hiding all panels');
    if (DOM.detailsPanel) DOM.detailsPanel.style.display = 'none';
    if (DOM.walletPanel) DOM.walletPanel.style.display = 'none';
    if (DOM.analyticsPanel) DOM.analyticsPanel.style.display = 'none';
    if (DOM.commodityPanel) {
      DOM.commodityPanel.style.display = 'none';
      console.log('Commodity panel hidden');
    }
  }
  
  static showTransactionDetails(txId) {
    const tx = state.transactions.find(t => t.id === txId);
    if (!tx) return;
    
    this.showPanel('details');
    
    const elements = {
      detailId: document.getElementById('detailId'),
      detailFrom: document.getElementById('detailFrom'),
      detailTo: document.getElementById('detailTo'),
      detailAmount: document.getElementById('detailAmount'),
      detailDesc: document.getElementById('detailDesc'),
      detailStatus: document.getElementById('detailStatus'),
      detailTs: document.getElementById('detailTs'),
      historyActions: document.getElementById('historyActions')
    };
    
    if (elements.detailId) elements.detailId.textContent = tx.id;
    if (elements.detailFrom) elements.detailFrom.textContent = tx.from;
    if (elements.detailTo) elements.detailTo.textContent = tx.to;
    if (elements.detailAmount) {
      let amountText = tx.asset === 'fiat' 
        ? Utils.formatCurrency(parseFloat(tx.amount))
        : `${parseFloat(tx.amount).toFixed(4)} ${tx.asset.toUpperCase()}`;
      if (tx.fiatValue) {
        amountText += ` (${Utils.formatCurrency(tx.fiatValue)})`;
      }
      if (tx.fee && tx.fee > 0) {
        amountText += ` (Fee: ${Utils.formatCurrency(tx.fee)})`;
      }
      elements.detailAmount.textContent = amountText;
    }
    if (elements.detailDesc) {
      let desc = tx.description;
      if (tx.paymentType === 'qrcode') desc += ' (QR Code Payment)';
      if (tx.asset !== 'fiat') desc += ` (${tx.asset.toUpperCase()} Transaction)`;
      elements.detailDesc.textContent = desc;
    }
    if (elements.detailStatus) {
      elements.detailStatus.innerHTML = `<span class="tx-status tx-status-${tx.status}">${tx.status}</span>`;
    }
    if (elements.detailTs) elements.detailTs.textContent = Utils.formatDate(tx.timestamp);
    if (elements.historyActions) {
      elements.historyActions.style.display = state.ui.historyMode ? 'block' : 'none';
    }
  }
  
  static toggleHistoryMode() {
    state.ui.historyMode = !state.ui.historyMode;
    const button = document.getElementById('historyModeButton');
    if (button) button.classList.toggle('active', state.ui.historyMode);
    
    const historyActions = document.getElementById('historyActions');
    if (historyActions) {
      historyActions.style.display = state.ui.historyMode ? 'block' : 'none';
    }
    
    RenderEngine.requestDraw();
    NotificationManager.show(
      state.ui.historyMode ? 'History mode enabled' : 'History mode disabled',
      'default'
    );
  }
  
  static toggleTheme() {
    state.ui.darkTheme = !state.ui.darkTheme;
    document.body.style.filter = state.ui.darkTheme ? 'none' : 'invert(1) hue-rotate(180deg)';
    if (DOM.themeToggle) DOM.themeToggle.textContent = state.ui.darkTheme ? '🌙' : '☀️';
    RenderEngine.requestDraw();
  }
  
  static showShutdownModal() {
    if (DOM.shutdownModal) DOM.shutdownModal.style.display = 'flex';
  }
  
  static hideShutdownModal() {
    if (DOM.shutdownModal) DOM.shutdownModal.style.display = 'none';
  }
}
	
    // ======================
    // Enhanced Notification System
    // ======================
    class NotificationManager {
      static queue = [];
      static isShowing = false;
      
      static show(message, type = 'default', duration = 3000) {
        this.queue.push({ message, type, duration });
        this.processQueue();
      }
      
      static processQueue() {
        if (this.isShowing || this.queue.length === 0) return;
        
        const { message, type, duration } = this.queue.shift();
        this.displayNotification(message, type, duration);
      }
      
      static displayNotification(message, type, duration) {
        this.isShowing = true;
        
        if (DOM.notification) {
          DOM.notification.textContent = message;
          DOM.notification.className = 'notification';
          
          if (type !== 'default') {
            DOM.notification.classList.add(`notification-${type}`);
          }
          
          DOM.notification.classList.add('show');
          
          setTimeout(() => {
            DOM.notification.classList.remove('show');
            this.isShowing = false;
            setTimeout(() => this.processQueue(), 400);
          }, duration);
        }
      }
    }
    // ======================
    // Enhanced QR Code System
    // ======================
    class QRCodeManager {
      static generateQRCode(amount, note = '') {
        state.currentQRCode = {
          recipient: state.userWallet.id,
          amount: amount,
          note: note,
          timestamp: new Date().toISOString()
        };
        
        const qrAmount = document.getElementById('qrAmount');
        const qrRecipient = document.getElementById('qrRecipient');
        
        if (qrAmount) qrAmount.textContent = Utils.formatCurrency(amount);
        if (qrRecipient) qrRecipient.textContent = state.userWallet.id;
        
        this.renderQRCode();
        if (DOM.qrcodeModal) DOM.qrcodeModal.style.display = 'flex';
        NotificationManager.show('QR Code generated! Share with the payer.', 'qrcode-notification');
      }
      
      static renderQRCode() {
        const canvas = document.getElementById('qrcodeCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 200, 200);
        
        // Enhanced QR code pattern
        ctx.fillStyle = 'black';
        const cellSize = 8;
        const gridSize = 25;
        
        // Generate more realistic QR pattern
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const shouldFill = this.getQRPattern(x, y, gridSize);
            if (shouldFill) {
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
        
        // Draw position detection patterns (corners)
        this.drawPositionMarkers(ctx, cellSize);
      }
      
      static getQRPattern(x, y, size) {
        // Simulate QR code data pattern
        const hash = (x * 31 + y * 17 + state.currentQRCode.amount * 13) % 100;
        return hash > 45 || this.isPositionMarker(x, y, size) || this.isTimingPattern(x, y, size);
      }
      
      static isPositionMarker(x, y, size) {
        const markers = [
          { x: 0, y: 0 }, // Top-left
          { x: size - 7, y: 0 }, // Top-right
          { x: 0, y: size - 7 } // Bottom-left
        ];
        
        return markers.some(marker => 
          x >= marker.x && x < marker.x + 7 && 
          y >= marker.y && y < marker.y + 7
        );
      }
      
      static isTimingPattern(x, y, size) {
        return (x === 6 && y > 7 && y < size - 8) || (y === 6 && x > 7 && x < size - 8);
      }
      
      static drawPositionMarkers(ctx, cellSize) {
        const positions = [
          { x: 0, y: 0 },
          { x: 17 * cellSize, y: 0 },
          { x: 0, y: 17 * cellSize }
        ];
        
        positions.forEach(pos => {
          // Outer square
          ctx.fillRect(pos.x, pos.y, 7 * cellSize, 7 * cellSize);
          ctx.fillStyle = 'white';
          ctx.fillRect(pos.x + cellSize, pos.y + cellSize, 5 * cellSize, 5 * cellSize);
          ctx.fillStyle = 'black';
          ctx.fillRect(pos.x + 2 * cellSize, pos.y + 2 * cellSize, 3 * cellSize, 3 * cellSize);
        });
      }
      
      static processQRPayment(qrData) {
        if (!qrData || !qrData.recipient || !qrData.amount) {
          NotificationManager.show('Invalid QR Code data!', 'error');
          return false;
        }
        
        if (qrData.recipient === state.userWallet.id) {
          NotificationManager.show('Cannot pay yourself!', 'warning');
          return false;
        }
        
        return WalletManager.processPayment(qrData.recipient, qrData.amount, qrData.note, 'standard', 'qrcode');
      }
      
      static simulateQRScan() {
        // Simulate scanning a QR code with sample data
        const sampleQRData = {
          recipient: 'DL-DEMO-' + Math.random().toString(36).substr(2, 8).toUpperCase(),
          amount: Math.floor(Math.random() * 100) + 10,
          note: 'QR Code Payment',
          timestamp: new Date().toISOString()
        };
        
        if (this.processQRPayment(sampleQRData)) {
          if (DOM.scanModal) DOM.scanModal.style.display = 'none';
          NotificationManager.show(`QR payment of ${Utils.formatCurrency(sampleQRData.amount)} processed!`, 'success');
        }
      }
    }
    // ======================
    // Enhanced Interaction Management
    // ======================
    class InteractionManager {
      static getBlockAtPosition(x, y) {
        if (state.ui.zoom < RenderEngine.SIMPLE_THRESHOLD) return -1;
        
        const blockSize = 40 * state.ui.zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Check visible blocks only for performance
        const visibleBlocks = RenderEngine.getVisibleBlocks(hexWidth, hexHeight);
        
        for (let i = visibleBlocks.length - 1; i >= 0; i--) {
          const { index, pos } = visibleBlocks[i];
          const dx = x - pos.x;
          const dy = y - pos.y;
          
          // Use hexagon collision detection
          if (this.isPointInHexagon(dx, dy, blockSize)) {
            return index;
          }
        }
        
        return -1;
      }
      
      static isPointInHexagon(x, y, radius) {
        // Simplified hexagon collision detection
        const distance = Math.sqrt(x * x + y * y);
        return distance <= radius;
      }
      
      static handleMouseMove(e) {
        if (!state.ui.isAuthenticated) return;
        
        if (state.ui.dragging) {
          if (DOM.canvas) DOM.canvas.style.cursor = 'grabbing';
          const deltaX = e.clientX - state.ui.lastMousePos.x;
          const deltaY = e.clientY - state.ui.lastMousePos.y;
          
          state.ui.dragOffset.x += deltaX;
          state.ui.dragOffset.y += deltaY;
          state.ui.lastMousePos = { x: e.clientX, y: e.clientY };
          
          RenderEngine.requestDraw();
        } else {
          const rect = DOM.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          const newHoveredIndex = this.getBlockAtPosition(mouseX, mouseY);
          
          if (newHoveredIndex !== state.ui.hoveredBlockIndex) {
            state.ui.hoveredBlockIndex = newHoveredIndex;
            if (DOM.canvas) DOM.canvas.style.cursor = newHoveredIndex >= 0 ? 'pointer' : 'grab';
            RenderEngine.requestDraw();
          }
        }
      }
      
      static handleMouseDown(e) {
        if (!state.ui.isAuthenticated) return;
        state.ui.dragging = true;
        state.ui.lastMousePos = { x: e.clientX, y: e.clientY };
      }
      
      static handleMouseUp() {
        state.ui.dragging = false;
        if (DOM.canvas) DOM.canvas.style.cursor = 'grab';
      }
      
      static handleClick() {
        if (!state.ui.isAuthenticated) return;
        
        if (state.ui.hoveredBlockIndex !== -1) {
          const block = state.blocks[state.ui.hoveredBlockIndex];
          state.ui.selectedTxId = block.txId;
          UIManager.showTransactionDetails(block.txId);
          RenderEngine.requestDraw();
        } else {
          state.ui.selectedTxId = null;
          UIManager.hidePanels();
          RenderEngine.requestDraw();
        }
      }
      
      static handleWheel(e) {
        if (!state.ui.isAuthenticated) return;
        
        e.preventDefault();
        
        if (e.ctrlKey || e.metaKey) {
          // Zoom
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          const newZoom = Utils.clamp(state.ui.zoom * zoomFactor, 0.1, 5);
          
          state.ui.zoom = newZoom;
          if (DOM.zoomSlider) DOM.zoomSlider.value = newZoom;
          if (DOM.zoomDisplay) DOM.zoomDisplay.textContent = newZoom.toFixed(1) + 'x';
          RenderEngine.updateZoomInfo();
        } else {
          // Pan
          state.ui.dragOffset.x -= e.deltaX;
          state.ui.dragOffset.y -= e.deltaY;
        }
        
        RenderEngine.requestDraw();
      }
      
      static handleKeyboard(e) {
        if (!state.ui.isAuthenticated) return;
        
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case 's':
              e.preventDefault();
              DataManager.saveToStorage();
              break;
            case 'o':
              e.preventDefault();
              DataManager.loadFromStorage();
              break;
            case '=':
            case '+':
              e.preventDefault();
              state.ui.zoom = Utils.clamp(state.ui.zoom + 0.1, 0.1, 5);
              this.updateZoomUI();
              break;
            case '-':
              e.preventDefault();
              state.ui.zoom = Utils.clamp(state.ui.zoom - 0.1, 0.1, 5);
              this.updateZoomUI();
              break;
          }
        }
        
        // Escape key to close panels
        if (e.key === 'Escape') {
          UIManager.hidePanels();
          state.ui.selectedTxId = null;
          RenderEngine.requestDraw();
        }
      }
      
      static updateZoomUI() {
        if (DOM.zoomSlider) DOM.zoomSlider.value = state.ui.zoom;
        if (DOM.zoomDisplay) DOM.zoomDisplay.textContent = state.ui.zoom.toFixed(1) + 'x';
        RenderEngine.updateZoomInfo();
        RenderEngine.requestDraw();
      }
    }
    // ======================
    // Enhanced Data Management
    // ======================
    class DataManager {
      static saveToStorage() {
        try {
          const saveData = {
            transactions: state.transactions,
            wallet: state.userWallet,
            version: '3.0.0',
            timestamp: new Date().toISOString()
          };
          
          localStorage.setItem('blockchainLedger_v3', JSON.stringify(saveData));
          NotificationManager.show('Ledger saved successfully!', 'success');
        } catch (e) {
          console.error('Error saving to storage:', e);
          NotificationManager.show('Failed to save: Storage quota exceeded', 'error');
        }
      }
      
      static loadFromStorage() {
        try {
          const saved = localStorage.getItem('blockchainLedger_v3');
          if (!saved) {
            // Try legacy format
            return this.loadLegacyFormat();
          }
          
          const data = JSON.parse(saved);
          
          if (data.transactions && Array.isArray(data.transactions)) {
            TransactionManager.clearLedger();
            
            data.transactions.forEach(tx => {
              state.transactions.push(tx);
              state.blocks.push({ type: 'source', txId: tx.id, data: tx });
              state.blocks.push({ type: 'destination', txId: tx.id, data: tx });
            });
            
            if (data.wallet) {
              state.userWallet = { ...state.userWallet, ...data.wallet };
              WalletManager.updateUI();
            }
            
            TransactionManager.updateDisplay();
            AnalyticsManager.updateRealTimeStats();
            NotificationManager.show(`Loaded ${data.transactions.length} transactions!`, 'success');
          }
        } catch (e) {
          console.error('Error loading from storage:', e);
          NotificationManager.show('Failed to load ledger: Invalid format', 'error');
        }
      }
      
      static loadLegacyFormat() {
        const legacy = localStorage.getItem('blockchainLedger');
        if (!legacy) {
          NotificationManager.show('No saved ledger found', 'warning');
          return;
        }
        
        try {
          const transactions = JSON.parse(legacy);
          if (Array.isArray(transactions)) {
            TransactionManager.clearLedger();
            transactions.forEach(tx => TransactionManager.addTransaction(tx));
            NotificationManager.show('Loaded legacy format successfully!', 'success');
          }
        } catch (e) {
          console.error('Error loading legacy format:', e);
          NotificationManager.show('Failed to load legacy format', 'error');
        }
      }
      
      static exportData() {
        const exportData = {
          transactions: state.transactions,
          wallet: state.userWallet,
          metadata: {
            version: '3.0.0',
            exportDate: new Date().toISOString(),
            totalTransactions: state.transactions.length,
            totalVolume: state.analytics.totalVolume
          }
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `blockchain-ledger-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        NotificationManager.show('Ledger exported successfully!', 'success');
      }
    }
    // ======================
    // Enhanced Shutdown Management
    // ======================
    class ShutdownManager {
      static async shutdown() {
        if (state.ui.isShuttingDown) return;
        
        state.ui.isShuttingDown = true;
        
        try {
          // Save all data first
          await this.saveAllData();
          
          // Stop animation loop
          if (state.ui.animationFrameId) {
            cancelAnimationFrame(state.ui.animationFrameId);
            state.ui.animationFrameId = null;
          }
          
          // Clear UI
          UIManager.hidePanels();
          
          // Reset authentication state
          state.ui.isAuthenticated = false;
          
          // Clear canvas
          if (DOM.ctx) {
            DOM.ctx.clearRect(0, 0, DOM.canvas.width, DOM.canvas.height);
          }
          
          // Hide controls
          if (DOM.controls) DOM.controls.style.display = 'none';
          
          // Show shutdown complete message
          NotificationManager.show('Direct Ledger Wallet shutdown complete. Data saved successfully.', 'success');
          
          // Reset shutdown flag after a delay
          setTimeout(() => {
            state.ui.isShuttingDown = false;
          }, 2000);
          
        } catch (error) {
          console.error('Shutdown error:', error);
          NotificationManager.show('Error during shutdown. Some data may not have been saved.', 'error');
          state.ui.isShuttingDown = false;
        }
      }
      
      static async saveAllData() {
        try {
          // Save transactions
          const saveData = {
            transactions: state.transactions,
            wallet: state.userWallet,
            version: '3.0.0',
            timestamp: new Date().toISOString(),
            shutdownTime: new Date().toISOString()
          };
          
          localStorage.setItem('blockchainLedger_v3', JSON.stringify(saveData));
          
          // Also save to a backup location
          localStorage.setItem('blockchainLedger_backup', JSON.stringify(saveData));
        } catch (error) {
          console.error('Error saving data during shutdown:', error);
          throw error;
        }
      }
      
      static restart() {
        // Clear shutdown state
        state.ui.isShuttingDown = false;
        
        // Show controls
        if (DOM.controls) DOM.controls.style.display = 'flex';
        
        // Restart authentication
        authManager.checkPin();
      }
    }
    // ======================
    // Commodity UI Setup
    // ======================
    function addCommodityUI() {
  // FIXED: Remove the duplicate button creation since we already have it in HTML
  
  // Only set up the event listeners for the existing buttons
  document.getElementById('buyGoldButton')?.addEventListener('click', () => {
    const amount = parseFloat(prompt('Enter amount in fiat to spend on gold:', '100'));
    if (!isNaN(amount) && amount > 0) {
      CommodityManager.buyCommodityTokens(amount, 'gold');
    }
  });
  
  document.getElementById('sellGoldButton')?.addEventListener('click', () => {
    const amount = parseFloat(prompt('Enter amount of gold tokens to sell:', '0.1'));
    if (!isNaN(amount) && amount > 0) {
      CommodityManager.sellCommodityTokens(amount, 'gold');
    }
  });
  
  document.getElementById('buySilverButton')?.addEventListener('click', () => {
    const amount = parseFloat(prompt('Enter amount in fiat to spend on silver:', '100'));
    if (!isNaN(amount) && amount > 0) {
      CommodityManager.buyCommodityTokens(amount, 'silver');
    }
  });
  
  document.getElementById('sellSilverButton')?.addEventListener('click', () => {
    const amount = parseFloat(prompt('Enter amount of silver tokens to sell:', '1'));
    if (!isNaN(amount) && amount > 0) {
      CommodityManager.sellCommodityTokens(amount, 'silver');
    }
  });
}

    // ======================
    // UI Adjustment Function
    // ======================
    function adjustUIElements() {
      const exitButton = document.getElementById('shutdownButton');
      if (exitButton) {
        exitButton.style.marginLeft = '50px';
        exitButton.style.paddingRight = '15px';
      }
      
      const modals = document.querySelectorAll('.modal');
      const panels = document.querySelectorAll('.panel');
      
      [...modals, ...panels].forEach(element => {
        element.style.backgroundColor = 'rgba(20, 20, 30, 0.95)';
        element.style.color = '#f0f0f0';
      });
      
      const historyElements = document.querySelectorAll('.payment-item, .tx-status');
      historyElements.forEach(element => {
        element.style.backgroundColor = 'rgba(30, 30, 40, 0.8)';
        element.style.color = '#e0e0e0';
      });
      
      const forkButton = document.getElementById('forkButton');
      if (forkButton) {
        forkButton.style.marginRight = '30px';
        forkButton.style.zIndex = '10';
        forkButton.style.position = 'relative';
        forkButton.style.display = 'inline-block';
        forkButton.style.visibility = 'visible';
      }
      
      const historyButton = document.getElementById('historyModeButton');
      if (historyButton) {
        historyButton.style.zIndex = '10';
        historyButton.style.position = 'relative';
        historyButton.style.display = 'inline-block';
        historyButton.style.visibility = 'visible';
      }
      
      const buttonContainer = exitButton?.parentElement;
      if (buttonContainer) {
        buttonContainer.style.gap = '20px';
        buttonContainer.style.overflow = 'visible';
      }
    }
    // ======================
    // Event Listeners Setup
    // ======================
    function setupEventListeners() {
      // Authentication
      if (DOM.pinSubmit) {
        DOM.pinSubmit.addEventListener('click', () => {
          authManager.validatePin(DOM.pinInput.value);
        });
      }
      
      if (DOM.pinInput) {
        DOM.pinInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            authManager.validatePin(DOM.pinInput.value);
          }
        });
      }
      
      // Shutdown
      if (DOM.shutdownButton) {
        DOM.shutdownButton.addEventListener('click', UIManager.showShutdownModal.bind(UIManager));
      }
      if (DOM.cancelShutdown) {
        DOM.cancelShutdown.addEventListener('click', UIManager.hideShutdownModal.bind(UIManager));
      }
      if (DOM.confirmShutdown) {
        DOM.confirmShutdown.addEventListener('click', () => {
          UIManager.hideShutdownModal();
          ShutdownManager.shutdown();
        });
      }
      
      // Canvas interactions
      if (DOM.canvas) {
        DOM.canvas.addEventListener('mousedown', InteractionManager.handleMouseDown.bind(InteractionManager));
        DOM.canvas.addEventListener('mouseup', InteractionManager.handleMouseUp.bind(InteractionManager));
        DOM.canvas.addEventListener('mousemove', Utils.throttle(InteractionManager.handleMouseMove.bind(InteractionManager), 16));
        DOM.canvas.addEventListener('click', InteractionManager.handleClick.bind(InteractionManager));
        DOM.canvas.addEventListener('wheel', InteractionManager.handleWheel.bind(InteractionManager), { passive: false });
        DOM.canvas.addEventListener('mouseleave', () => {
          state.ui.dragging = false;
          state.ui.hoveredBlockIndex = -1;
          RenderEngine.requestDraw();
        });
      }
      
      // Window events
      window.addEventListener('resize', Utils.debounce(CanvasManager.resizeCanvas.bind(CanvasManager), 250));
      window.addEventListener('keydown', InteractionManager.handleKeyboard.bind(InteractionManager));
      
      // UI Controls
      document.getElementById('addTxButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && DOM.txModal) DOM.txModal.style.display = 'flex';
      });
      
      document.getElementById('generateButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) TransactionManager.generateGalaxy(1000);
      });
      
      document.getElementById('clearButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && confirm('Clear entire ledger?')) {
          TransactionManager.clearLedger();
          NotificationManager.show('Ledger cleared', 'warning');
        }
      });
      
      document.getElementById('saveButton')?.addEventListener('click', DataManager.saveToStorage.bind(DataManager));
      document.getElementById('loadButton')?.addEventListener('click', DataManager.loadFromStorage.bind(DataManager));
      
      document.getElementById('paymentButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && DOM.paymentModal) DOM.paymentModal.style.display = 'flex';
      });
      
      document.getElementById('walletButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) UIManager.showPanel('wallet');
      });
      
      document.getElementById('analyticsButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated) UIManager.showPanel('analytics');
      });
      
     // In the setupEventListeners function, replace the commodity button listener with this:

		const commodityButton = document.getElementById('commodityButton');
		console.log('Commodity button found:', !!commodityButton); // Check if button exists

		if (commodityButton) {
		  commodityButton.addEventListener('click', () => {
			console.log('Commodity button clicked');
			console.log('Authentication status:', state.ui.isAuthenticated);
			
			if (state.ui.isAuthenticated) {
			  console.log('Attempting to show commodity panel');
			  UIManager.showPanel('commodity');
			} else {
			  console.log('User not authenticated');
			  NotificationManager.show('Please authenticate first', 'warning');
			}
		  });
		} else {
		  console.error('Commodity button not found in DOM');
		}

      document.getElementById('generateQRButton')?.addEventListener('click', () => {
        if (!state.ui.isAuthenticated) return;
        const amount = parseFloat(prompt('Enter amount for QR code:', '25.00'));
        if (!isNaN(amount) && amount > 0) {
          const note = prompt('Enter note (optional):', '') || '';
          QRCodeManager.generateQRCode(amount, note);
        }
      });
      
      document.getElementById('scanQRButton')?.addEventListener('click', () => {
        if (state.ui.isAuthenticated && DOM.scanModal) DOM.scanModal.style.display = 'flex';
      });
      
      document.getElementById('historyModeButton')?.addEventListener('click', UIManager.toggleHistoryMode.bind(UIManager));
      
      document.getElementById('forkButton')?.addEventListener('click', () => {
        if (state.ui.selectedTxId) {
          TransactionManager.forkTransaction(state.ui.selectedTxId);
        } else {
          NotificationManager.show('Select a transaction first!', 'warning');
        }
      });
      
      // Search and filter
      if (DOM.searchBox) {
        DOM.searchBox.addEventListener('input', Utils.debounce((e) => {
          state.ui.searchQuery = e.target.value.toLowerCase();
          RenderEngine.requestDraw();
        }, 300));
      }
      
      if (DOM.filterSelect) {
        DOM.filterSelect.addEventListener('change', (e) => {
          state.ui.filterType = e.target.value;
          RenderEngine.requestDraw();
        });
      }
      
      if (DOM.zoomSlider) {
        DOM.zoomSlider.addEventListener('input', (e) => {
          state.ui.zoom = parseFloat(e.target.value);
          if (DOM.zoomDisplay) DOM.zoomDisplay.textContent = state.ui.zoom.toFixed(1) + 'x';
          RenderEngine.updateZoomInfo();
          RenderEngine.requestDraw();
        });
      }
      
      // Theme toggle
      if (DOM.themeToggle) {
        DOM.themeToggle.addEventListener('click', UIManager.toggleTheme.bind(UIManager));
      }
      
      // Modal close buttons
      document.getElementById('closeTxModal')?.addEventListener('click', () => {
        if (DOM.txModal) DOM.txModal.style.display = 'none';
      });
      
      document.getElementById('closePaymentModal')?.addEventListener('click', () => {
        if (DOM.paymentModal) DOM.paymentModal.style.display = 'none';
      });
      
      document.getElementById('closeQRModal')?.addEventListener('click', () => {
        if (DOM.qrcodeModal) DOM.qrcodeModal.style.display = 'none';
      });
      
      document.getElementById('closeScanModal')?.addEventListener('click', () => {
        if (DOM.scanModal) DOM.scanModal.style.display = 'none';
      });
      
      document.getElementById('closeAnalyticsModal')?.addEventListener('click', () => {
        if (DOM.analyticsModal) DOM.analyticsModal.style.display = 'none';
      });
      
      // Forms
      const txForm = document.getElementById('txForm');
      if (txForm) {
        txForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const formData = new FormData(e.target);
          const newTx = {
            from: document.getElementById('txFrom')?.value || '',
            to: document.getElementById('txTo')?.value || '',
            amount: parseFloat(document.getElementById('txAmount')?.value || 0),
            description: document.getElementById('txDesc')?.value || 'Manual Transaction'
          };
          
          TransactionManager.addTransaction(newTx);
          if (DOM.txModal) DOM.txModal.style.display = 'none';
          e.target.reset();
          NotificationManager.show('Transaction added successfully!', 'success');
        });
      }
      
      const paymentForm = document.getElementById('paymentForm');
      if (paymentForm) {
        paymentForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const recipient = document.getElementById('paymentRecipient')?.value || '';
          const amount = parseFloat(document.getElementById('paymentAmount')?.value || 0);
          const note = document.getElementById('paymentNote')?.value || '';
          const speed = document.getElementById('paymentSpeed')?.value || 'standard';
          
          if (WalletManager.processPayment(recipient, amount, note, speed)) {
            if (DOM.paymentModal) DOM.paymentModal.style.display = 'none';
            e.target.reset();
          }
        });
      }
      
      // QR Code simulation
      document.getElementById('simulateScan')?.addEventListener('click', QRCodeManager.simulateQRScan.bind(QRCodeManager));
    }
    // ======================
    // Global Functions (for onclick handlers)
    // ======================
    window.moveTransaction = function() {
      NotificationManager.show('Move functionality: Drag to reorder timeline!', 'default');
    };
    window.deleteTransaction = function() {
      if (state.ui.selectedTxId && confirm('Delete this transaction from history?')) {
        TransactionManager.deleteTransaction(state.ui.selectedTxId);
      }
    };
    window.forkFromHere = function() {
      if (state.ui.selectedTxId) {
        TransactionManager.forkTransaction(state.ui.selectedTxId);
      }
    };
    window.openPaymentModal = function() {
      if (DOM.paymentModal) DOM.paymentModal.style.display = 'flex';
    };
    window.addFunds = function() {
      const amount = parseFloat(prompt('Enter amount to add:', '100.00'));
      if (!isNaN(amount) && amount > 0) {
        WalletManager.addFunds(amount);
      }
    };
    window.restartLedger = function() {
      if (confirm('Restart the Direct Ledger Wallet?')) {
        ShutdownManager.restart();
      }
    };
    // ======================
    // Enhanced Application Initialization
    // ======================
    function initializeApp() {
      setupEventListeners();
      
      addCommodityUI();
      
      setInterval(() => {
        CommodityManager.updatePrices();
      }, 30000);
      
      RenderEngine.animate();
      authManager.checkPin();
      
      adjustUIElements();
      
      console.log(`
🚀 Enhanced Blockchain Ledger v3.0.0 Loaded!
🪙 Now with Gold and Silver backing!
Keyboard shortcuts:
• Ctrl/Cmd + S: Save ledger
• Ctrl/Cmd + O: Load ledger  
• Ctrl/Cmd + Plus: Zoom in
• Ctrl/Cmd + Minus: Zoom out
• Escape: Close panels
• Mouse wheel + Ctrl: Zoom
• Mouse wheel: Pan
• Shutdown button: Power off ledger
      `);
    }
    document.addEventListener('DOMContentLoaded', initializeApp);
  </script>
</body>
</html>
