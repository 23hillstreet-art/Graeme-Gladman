<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scalable Temporal Blockchain Ledger</title>
  <style>
    :root {
        --source-color: #3498db;
        --dest-color: #2ecc71;
        --rung-color: #e74c3c;
        --highlight-color: #f1c40f;
        --bg-color-1: #0a0a0f;
        --bg-color-2: #1a1a2e;
        --pixel-glow: #ffffff;
        --fork-color: #9b59b6;
        --payment-color: #16a085;
        --qrcode-color: #2c3e50;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      overflow: hidden;
      background: radial-gradient(ellipse at center, var(--bg-color-2) 0%, var(--bg-color-1) 100%);
      color: #ecf0f1;
    }
    
    /* PIN Modal Styles */
    .pin-modal {
      display: flex;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
    }
    .pin-content {
      background-color: var(--bg-color-2);
      padding: 2rem;
      border-radius: 15px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
      text-align: center;
    }
    .pin-input {
      width: 100%;
      padding: 12px;
      margin: 15px 0;
      border-radius: 8px;
      border: 2px solid var(--highlight-color);
      background: rgba(52, 73, 94, 0.8);
      color: white;
      font-size: 1.2rem;
      text-align: center;
      letter-spacing: 5px;
    }
    .pin-message {
      margin-top: 1rem;
      color: var(--highlight-color);
    }
    
    /* Transaction Modal Styles */
    .tx-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
    }
    .tx-content {
      background-color: var(--bg-color-2);
      padding: 2rem;
      border-radius: 15px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
    }
    .tx-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .tx-form input, .tx-form select {
      padding: 10px;
      border-radius: 8px;
      border: 2px solid var(--highlight-color);
      background: rgba(52, 73, 94, 0.8);
      color: white;
    }
    .tx-form label {
      font-weight: 600;
      color: var(--highlight-color);
    }
    .close-btn {
      align-self: flex-end;
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    /* Payment Modal Styles */
    .payment-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
    }
    .payment-content {
      background-color: var(--bg-color-2);
      padding: 2rem;
      border-radius: 15px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
    }
    .payment-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .payment-form input, .payment-form select {
      padding: 10px;
      border-radius: 8px;
      border: 2px solid var(--payment-color);
      background: rgba(52, 73, 94, 0.8);
      color: white;
    }
    .payment-form label {
      font-weight: 600;
      color: var(--payment-color);
    }
    .wallet-balance {
      background: rgba(22, 160, 133, 0.2);
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      text-align: center;
      border: 1px solid var(--payment-color);
    }
    .wallet-balance h3 {
      margin: 0 0 0.5rem 0;
      color: var(--payment-color);
    }
    .balance-amount {
      font-size: 1.8rem;
      font-weight: bold;
    }
    
    /* QR Code Modal Styles */
    .qrcode-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
    }
    .qrcode-content {
      background-color: var(--bg-color-2);
      padding: 2rem;
      border-radius: 15px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
      text-align: center;
    }
    .qrcode-container {
      margin: 1.5rem 0;
      padding: 1rem;
      background: white;
      border-radius: 8px;
      display: inline-block;
    }
    .qrcode-info {
      margin-top: 1rem;
      font-size: 1.1rem;
    }
    .qrcode-amount {
      font-weight: bold;
      color: var(--payment-color);
      font-size: 1.5rem;
    }
    
    /* Scan Modal Styles */
    .scan-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
    }
    .scan-content {
      background-color: var(--bg-color-2);
      padding: 2rem;
      border-radius: 15px;
      width: 90%;
      max-width: 500px;
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
      text-align: center;
    }
    .scan-area {
      margin: 1.5rem 0;
      height: 300px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 2px dashed var(--qrcode-color);
    }
    .scan-placeholder {
      color: var(--qrcode-color);
      font-size: 1.2rem;
    }
    .scan-info {
      margin-top: 1rem;
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    #controls {
      padding: 1rem;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(15px);
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
    }
    button:hover { 
        transform: translateY(-2px); 
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
    }
    
    .mode-button.active {
        background: linear-gradient(135deg, var(--highlight-color), #f39c12);
        box-shadow: 0 0 20px rgba(241, 196, 64, 0.6);
    }
    
    .payment-button {
        background: linear-gradient(135deg, var(--payment-color), #1abc9c) !important;
    }
    
    .qrcode-button {
        background: linear-gradient(135deg, var(--qrcode-color), #34495e) !important;
    }
    
    #searchBox {
        padding: 0.5rem;
        border-radius: 8px;
        border: 2px solid var(--highlight-color);
        background: rgba(52, 73, 94, 0.8);
        color: white;
        width: 250px;
        backdrop-filter: blur(10px);
    }
    #filterSelect {
        padding: 0.5rem;
        border-radius: 8px;
        border: 2px solid var(--highlight-color);
        background: rgba(52, 73, 94, 0.8);
        color: white;
    }
    #zoomDisplay, #countDisplay {
      font-weight: 600;
      background: rgba(0, 0, 0, 0.4);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    canvas { 
        display: block; 
        cursor: grab; 
        image-rendering: crisp-edges;
    }
    canvas:active { cursor: grabbing; }
    
    .details-panel {
      position: fixed;
      left: 10px;
      bottom: 10px;
      width: 320px;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 15px;
      padding: 1.5rem;
      z-index: 150;
      box-shadow: 0 8px 40px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
      display: none;
      animation: slideIn 0.4s ease;
    }
    .details-panel h3 { 
        margin-top: 0; 
        border-bottom: 2px solid var(--highlight-color); 
        padding-bottom: 0.5rem;
        color: var(--highlight-color);
    }
    .details-panel p { margin: 0.5rem 0; line-height: 1.5; }
    .detail-source { color: var(--source-color); }
    .detail-dest { color: var(--dest-color); }
    .detail-amount { color: var(--rung-color); }
    
    .history-mode {
        background: linear-gradient(135deg, var(--fork-color), #8e44ad) !important;
    }
    
    .zoom-info {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 1rem;
        border-radius: 10px;
        border-left: 4px solid var(--highlight-color);
        font-size: 0.9em;
        max-width: 200px;
    }
    
    .notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(46, 204, 113, 0.9);
        color: white;
        padding: 1rem;
        border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 200;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .payment-notification {
        background: rgba(22, 160, 133, 0.9) !important;
    }
    
    .qrcode-notification {
        background: rgba(44, 62, 80, 0.9) !important;
    }
    
    @keyframes slideIn {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
    }
    
    @keyframes pixelPulse {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
    }
    
    @media (max-width: 768px) {
        #controls {
            padding: 0.5rem;
            gap: 0.3rem;
        }
        
        .control-group {
            flex-direction: column;
            gap: 0.2rem;
        }
        
        button {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }
        
        #searchBox {
            width: 150px;
        }
        
        .details-panel {
            width: 280px;
            padding: 1rem;
        }
    }
  </style>
</head>
<body>
  <!-- PIN Modal -->
  <div id="pinModal" class="pin-modal">
    <div class="pin-content">
      <h2>Enter PIN</h2>
      <input type="password" id="pinInput" class="pin-input" maxlength="4" placeholder="••••">
      <div id="pinMessage" class="pin-message"></div>
      <button id="pinSubmit">Access Ledger</button>
    </div>
  </div>
  <!-- Transaction Modal -->
  <div id="txModal" class="tx-modal">
    <div class="tx-content">
      <button id="closeTxModal" class="close-btn">&times;</button>
      <h2>Add Transaction</h2>
      <form id="txForm" class="tx-form">
        <div>
          <label for="txFrom">From:</label>
          <input type="text" id="txFrom" required>
        </div>
        <div>
          <label for="txTo">To:</label>
          <input type="text" id="txTo" required>
        </div>
        <div>
          <label for="txAmount">Amount:</label>
          <input type="number" id="txAmount" step="0.01" min="0.01" required>
        </div>
        <div>
          <label for="txDesc">Description:</label>
          <input type="text" id="txDesc">
        </div>
        <button type="submit">Add Transaction</button>
      </form>
    </div>
  </div>
  
  <!-- Payment Modal -->
  <div id="paymentModal" class="payment-modal">
    <div class="payment-content">
      <button id="closePaymentModal" class="close-btn">&times;</button>
      <h2>DirectLedger Payment</h2>
      <div class="wallet-balance">
        <h3>Your Wallet Balance</h3>
        <div class="balance-amount" id="walletBalance">$0.00</div>
      </div>
      <form id="paymentForm" class="payment-form">
        <div>
          <label for="paymentRecipient">Recipient ID:</label>
          <input type="text" id="paymentRecipient" placeholder="Enter recipient's wallet ID" required>
        </div>
        <div>
          <label for="paymentAmount">Amount:</label>
          <input type="number" id="paymentAmount" step="0.01" min="0.01" required>
        </div>
        <div>
          <label for="paymentNote">Note (optional):</label>
          <input type="text" id="paymentNote" placeholder="What's this payment for?">
        </div>
        <div>
          <label for="paymentSpeed">Transfer Speed:</label>
          <select id="paymentSpeed">
            <option value="instant">Instant (0.5% fee)</option>
            <option value="fast" selected>Fast (0.2% fee)</option>
            <option value="standard">Standard (no fee)</option>
          </select>
        </div>
        <button type="submit" class="payment-button">Send Payment</button>
      </form>
    </div>
  </div>
  
  <!-- QR Code Modal -->
  <div id="qrcodeModal" class="qrcode-modal">
    <div class="qrcode-content">
      <button id="closeQRModal" class="close-btn">&times;</button>
      <h2>Scan to Pay</h2>
      <div class="qrcode-container">
        <canvas id="qrcodeCanvas" width="200" height="200"></canvas>
      </div>
      <div class="qrcode-info">
        <div>Amount: <span class="qrcode-amount" id="qrAmount">$0.00</span></div>
        <div>To: <span id="qrRecipient">Your Wallet</span></div>
      </div>
      <div style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.8;">
        Show this QR code to the payer or share it with them
      </div>
    </div>
  </div>
  
  <!-- Scan QR Code Modal -->
  <div id="scanModal" class="scan-modal">
    <div class="scan-content">
      <button id="closeScanModal" class="close-btn">&times;</button>
      <h2>Scan QR Code to Pay</h2>
      <div class="scan-area">
        <div class="scan-placeholder">
          <div>📷 Camera Preview</div>
          <div style="font-size: 0.9rem; margin-top: 0.5rem;">Point camera at QR code</div>
        </div>
      </div>
      <div class="scan-info">
        This would access your device camera to scan QR codes in a real implementation
      </div>
      <button id="simulateScan" class="qrcode-button" style="margin-top: 1rem;">Simulate QR Scan</button>
    </div>
  </div>
  
  <div id="controls">
    <div class="control-group">
      <button id="addTxButton">✨ Add Transaction</button>
      <button id="generateButton">🌌 Generate Galaxy</button>
      <button id="clearButton">🗑️ Clear Ledger</button>
    </div>
    
    <div class="control-group">
      <button id="paymentButton" class="payment-button">💳 DirectLedger Payment</button>
      <button id="walletButton" class="payment-button">👛 My Wallet</button>
    </div>
    
    <div class="control-group">
      <button id="generateQRButton" class="qrcode-button">📱 Generate QR Code</button>
      <button id="scanQRButton" class="qrcode-button">📷 Scan QR Code</button>
    </div>
    
    <div class="control-group">
      <button id="historyModeButton" class="mode-button">⏳ History Mode</button>
      <button id="forkButton">🔀 Fork Timeline</button>
    </div>
    
    <div class="control-group">
      <input type="search" id="searchBox" placeholder="Search From, To, ID...">
      <select id="filterSelect">
        <option value="all">All Transactions</option>
        <option value="source">Source Only</option>
        <option value="destination">Destination Only</option>
        <option value="payment">Payments Only</option>
        <option value="qrcode">QR Code Payments</option>
      </select>
    </div>
    
    <div class="control-group">
      <button id="saveButton">💾 Save Ledger</button>
      <button id="loadButton">📂 Load Ledger</button>
    </div>
    
    <div class="control-group">
      <label>Zoom:</label>
      <input type="range" id="zoomSlider" min="0.1" max="5" value="1" step="0.1" />
      <span id="zoomDisplay">1.0x</span>
    </div>
    
    <div class="control-group">
      <span id="countDisplay">Transactions: 0</span>
    </div>
  </div>
  
  <div class="zoom-info" id="zoomInfo">
    <strong>Galaxy View</strong><br>
    Each pixel represents a transaction. Blue = source, Green = destination.
  </div>
  
  <canvas id="canvas"></canvas>
  
  <div id="detailsPanel" class="details-panel">
    <h3>Transaction Details</h3>
    <p><strong>ID:</strong> <span id="detailId"></span></p>
    <p><strong>From:</strong> <span id="detailFrom" class="detail-source"></span></p>
    <p><strong>To:</strong> <span id="detailTo" class="detail-dest"></span></p>
    <p><strong>Amount:</strong> <span id="detailAmount" class="detail-amount"></span></p>
    <p><strong>Description:</strong> <span id="detailDesc"></span></p>
    <p><strong>Timestamp:</strong> <span id="detailTs"></span></p>
    <div id="historyActions" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #444;">
      <button onclick="moveTransaction()" style="margin-right: 0.5rem;">📋 Move</button>
      <button onclick="deleteTransaction()" style="margin-right: 0.5rem;">❌ Delete</button>
      <button onclick="forkFromHere()">🔀 Fork Here</button>
    </div>
  </div>
  
  <!-- Wallet Panel -->
  <div id="walletPanel" class="details-panel" style="right: 10px; left: auto; width: 350px;">
    <h3>DirectLedger Wallet</h3>
    <div style="background: rgba(22, 160, 133, 0.2); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; text-align: center;">
      <div style="font-size: 0.9rem; opacity: 0.8;">Wallet ID</div>
      <div id="walletId" style="font-family: monospace; word-break: break-all; font-weight: bold;">DL-XXXX-XXXX-XXXX</div>
    </div>
    <div style="background: rgba(22, 160, 133, 0.2); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; text-align: center;">
      <div style="font-size: 0.9rem; opacity: 0.8;">Available Balance</div>
      <div id="walletPanelBalance" style="font-size: 1.5rem; font-weight: bold;">$0.00</div>
    </div>
    <div style="margin-bottom: 1rem;">
      <h4 style="margin-top: 0; color: var(--payment-color);">Recent Payments</h4>
      <div id="recentPayments" style="max-height: 150px; overflow-y: auto;">
        <p style="opacity: 0.6; text-align: center;">No payments yet</p>
      </div>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button onclick="document.getElementById('paymentModal').style.display='flex'" style="flex: 1;">Send Money</button>
      <button onclick="addFunds()" style="flex: 1;">Add Funds</button>
    </div>
  </div>
  
  <div id="notification" class="notification"></div>
  
  <script>
    /**
     * Scalable Temporal Blockchain Ledger with DirectLedger Payment System and QR Code Support
     * A high-performance visualization tool for blockchain transactions
     * 
     * @version 2.1.0
     * @author Your Name
     * @license MIT
     */
    'use strict';
    // ======================
    // DOM Element References
    // ======================
    
    // Authentication elements
    const pinModal = document.getElementById('pinModal');
    const pinInput = document.getElementById('pinInput');
    const pinSubmit = document.getElementById('pinSubmit');
    const pinMessage = document.getElementById('pinMessage');
    
    // Transaction modal elements
    const txModal = document.getElementById('txModal');
    const txForm = document.getElementById('txForm');
    const closeTxModal = document.getElementById('closeTxModal');
    
    // Payment modal elements
    const paymentModal = document.getElementById('paymentModal');
    const paymentForm = document.getElementById('paymentForm');
    const closePaymentModal = document.getElementById('closePaymentModal');
    const walletBalance = document.getElementById('walletBalance');
    const walletPanel = document.getElementById('walletPanel');
    const walletId = document.getElementById('walletId');
    const walletPanelBalance = document.getElementById('walletPanelBalance');
    const recentPayments = document.getElementById('recentPayments');
    
    // QR Code modal elements
    const qrcodeModal = document.getElementById('qrcodeModal');
    const closeQRModal = document.getElementById('closeQRModal');
    const qrcodeCanvas = document.getElementById('qrcodeCanvas');
    const qrAmount = document.getElementById('qrAmount');
    const qrRecipient = document.getElementById('qrRecipient');
    
    // Scan QR Code modal elements
    const scanModal = document.getElementById('scanModal');
    const closeScanModal = document.getElementById('closeScanModal');
    const simulateScan = document.getElementById('simulateScan');
    
    // Canvas and UI elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Control elements
    const addTxButton = document.getElementById('addTxButton');
    const generateButton = document.getElementById('generateButton');
    const clearButton = document.getElementById('clearButton');
    const saveButton = document.getElementById('saveButton');
    const loadButton = document.getElementById('loadButton');
    const historyModeButton = document.getElementById('historyModeButton');
    const forkButton = document.getElementById('forkButton');
    const paymentButton = document.getElementById('paymentButton');
    const walletButton = document.getElementById('walletButton');
    const generateQRButton = document.getElementById('generateQRButton');
    const scanQRButton = document.getElementById('scanQRButton');
    const countDisplay = document.getElementById('countDisplay');
    const detailsPanel = document.getElementById('detailsPanel');
    const searchBox = document.getElementById('searchBox');
    const filterSelect = document.getElementById('filterSelect');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const zoomInfo = document.getElementById('zoomInfo');
    
    // ======================
    // Application State
    // ======================
    
    /**
     * Core data structures
     * transactions: Array of transaction objects
     * blocks: Array of visual block objects (source/destination pairs)
     */
    let transactions = [];
    let blocks = [];
    
    /**
     * DirectLedger Payment System State
     */
    let userWallet = {
      id: '',
      balance: 0,
      transactions: []
    };
    
    /**
     * QR Code Payment State
     */
    let currentQRCode = {
      recipient: '',
      amount: 0,
      note: '',
      timestamp: null
    };
    
    /**
     * UI state variables
     */
    let zoom = 1.0;                          // Current zoom level
    let dragOffset = { x: 0, y: 0 };         // Pan offset
    let dragging = false;                     // Is user dragging?
    let lastMousePos = { x: 0, y: 0 };       // Last mouse position for drag calculation
    let hoveredBlockIndex = -1;              // Currently hovered block index
    let selectedTxId = null;                  // Selected transaction ID
    let searchQuery = '';                     // Current search query
    let filterType = 'all';                  // Current filter type
    let historyMode = false;                  // History mode toggle
    let needsRedraw = true;                   // Flag to trigger redraw
    let animationFrameId = null;              // RequestAnimationFrame ID
    let isAuthenticated = false;              // Authentication status
    
    /**
     * Performance optimization: Object pool for blocks
     * Reduces garbage collection by reusing objects
     */
    const blockPool = [];
    
    /**
     * Get a block from the pool or create a new one
     * @returns {Object} A block object
     */
    function getBlockFromPool() {
        return blockPool.length ? blockPool.pop() : {};
    }
    
    /**
     * Release a block back to the pool
     * @param {Object} block - The block to release
     */
    function releaseBlockToPool(block) {
        blockPool.push(block);
    }
    
    // ======================
    // Constants
    // ======================
    
    /**
     * Level-of-detail thresholds for rendering optimization
     * PIXEL_THRESHOLD: Below this zoom, show pixels
     * SIMPLE_THRESHOLD: Below this zoom, show simple shapes
     */
    const PIXEL_THRESHOLD = 0.3;
    const SIMPLE_THRESHOLD = 0.8;
    
    // ======================
    // Authentication System
    // ======================
    
    /**
     * Initialize PIN authentication
     * Checks if PIN is set and prompts for entry if needed
     */
    function checkPin() {
        const savedPin = localStorage.getItem('ledgerPin');
        if (savedPin) {
            // PIN exists, prompt for entry
            pinModal.style.display = 'flex';
        } else {
            // First time use - set a PIN
            pinMessage.textContent = 'Set a PIN to secure your ledger';
            pinSubmit.textContent = 'Set PIN';
            pinModal.style.display = 'flex';
        }
    }
    
    // PIN submission handler
    pinSubmit.addEventListener('click', () => {
        const pin = pinInput.value;
        if (pin.length !== 4) {
            pinMessage.textContent = 'PIN must be 4 digits';
            return;
        }
        
        const savedPin = localStorage.getItem('ledgerPin');
        if (!savedPin) {
            // Save new PIN
            localStorage.setItem('ledgerPin', pin);
            isAuthenticated = true;
            pinModal.style.display = 'none';
            showNotification('PIN set successfully!');
            initializeApplication();
        } else if (pin === savedPin) {
            // Correct PIN
            isAuthenticated = true;
            pinModal.style.display = 'none';
            initializeApplication();
        } else {
            // Incorrect PIN
            pinMessage.textContent = 'Incorrect PIN. Try again.';
            pinInput.value = '';
        }
    });
    
    /**
     * Initialize the application after successful authentication
     */
    function initializeApplication() {
        resizeCanvas();
        updateZoomInfo();
        
        // Initialize DirectLedger Wallet
        initializeWallet();
        
        // Auto-generate a small galaxy for demo
        setTimeout(() => {
            generateGalaxy(100);
        }, 500);
    }
    
    // ======================
    // DirectLedger Payment System
    // ======================
    
    /**
     * Initialize user wallet
     */
    function initializeWallet() {
        // Try to load wallet from localStorage
        const savedWallet = localStorage.getItem('directLedgerWallet');
        if (savedWallet) {
            userWallet = JSON.parse(savedWallet);
        } else {
            // Create new wallet
            userWallet = {
                id: generateWalletId(),
                balance: 100.00, // Starting balance for demo
                transactions: []
            };
            saveWallet();
        }
        
        // Update UI
        updateWalletUI();
    }
    
    /**
     * Generate a unique wallet ID
     * @returns {string} Wallet ID
     */
    function generateWalletId() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = 'DL-';
        for (let i = 0; i < 12; i++) {
            if (i > 0 && i % 4 === 0) result += '-';
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }
    
    /**
     * Save wallet to localStorage
     */
    function saveWallet() {
        localStorage.setItem('directLedgerWallet', JSON.stringify(userWallet));
    }
    
    /**
     * Update wallet UI elements
     */
    function updateWalletUI() {
        walletId.textContent = userWallet.id;
        walletBalance.textContent = `$${userWallet.balance.toFixed(2)}`;
        walletPanelBalance.textContent = `$${userWallet.balance.toFixed(2)}`;
        
        // Update recent payments
        if (userWallet.transactions.length === 0) {
            recentPayments.innerHTML = '<p style="opacity: 0.6; text-align: center;">No payments yet</p>';
        } else {
            recentPayments.innerHTML = '';
            const recent = userWallet.transactions.slice(-5).reverse();
            recent.forEach(tx => {
                const isOutgoing = tx.from === userWallet.id;
                const txEl = document.createElement('div');
                txEl.style.padding = '0.5rem';
                txEl.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                txEl.innerHTML = `
                    <div style="display: flex; justify-content: space-between;">
                        <span>${isOutgoing ? 'To: ' + tx.to.substring(0, 8) + '...' : 'From: ' + tx.from.substring(0, 8) + '...'}</span>
                        <span style="font-weight: bold; color: ${isOutgoing ? '#e74c3c' : '#2ecc71'};">
                            ${isOutgoing ? '-' : '+'}$${tx.amount}
                        </span>
                    </div>
                    <div style="font-size: 0.8rem; opacity: 0.7;">${new Date(tx.timestamp).toLocaleDateString()}</div>
                `;
                recentPayments.appendChild(txEl);
            });
        }
    }
    
    /**
     * Show wallet panel
     */
    function showWallet() {
        updateWalletUI();
        walletPanel.style.display = 'block';
        detailsPanel.style.display = 'none';
    }
    
    /**
     * Add funds to wallet (demo function)
     */
    function addFunds() {
        const amount = parseFloat(prompt('Enter amount to add to your wallet:', '50.00'));
        if (!isNaN(amount) && amount > 0) {
            userWallet.balance += amount;
            
            // Add transaction record
            userWallet.transactions.push({
                id: `ADD-${Date.now()}`,
                from: 'SYSTEM',
                to: userWallet.id,
                amount: amount,
                description: 'Funds Added',
                timestamp: new Date().toISOString(),
                type: 'add_funds'
            });
            
            saveWallet();
            updateWalletUI();
            showNotification(`Added $${amount.toFixed(2)} to your wallet!`, 'payment-notification');
        }
    }
    
    /**
     * Process a DirectLedger payment
     * @param {string} recipient - Recipient wallet ID
     * @param {number} amount - Payment amount
     * @param {string} note - Payment note
     * @param {string} speed - Transfer speed
     * @param {string} paymentType - Type of payment (standard or qrcode)
     */
    function processPayment(recipient, amount, note, speed, paymentType = 'standard') {
        // Calculate fee based on speed
        let fee = 0;
        if (speed === 'instant') fee = amount * 0.005;
        else if (speed === 'fast') fee = amount * 0.002;
        
        const totalAmount = amount + fee;
        
        // Check if user has enough balance
        if (userWallet.balance < totalAmount) {
            showNotification('Insufficient balance for this payment!', 'payment-notification');
            return false;
        }
        
        // Create payment transaction
        const paymentTx = {
            id: `${paymentType === 'qrcode' ? 'QRP' : 'PAY'}-${Date.now()}`,
            from: userWallet.id,
            to: recipient,
            amount: amount,
            fee: fee,
            description: note || 'DirectLedger Payment',
            timestamp: new Date().toISOString(),
            speed: speed,
            type: 'payment',
            paymentType: paymentType,
            status: 'pending'
        };
        
        // Deduct from user balance
        userWallet.balance -= totalAmount;
        
        // Add to wallet transactions
        userWallet.transactions.push(paymentTx);
        
        // Add to main ledger for visualization
        transactions.push(paymentTx);
        blocks.push({ type: 'source', txId: paymentTx.id, data: paymentTx });
        blocks.push({ type: 'destination', txId: paymentTx.id, data: paymentTx });
        
        // Simulate payment processing
        setTimeout(() => {
            paymentTx.status = 'completed';
            saveWallet();
            showNotification(`${paymentType === 'qrcode' ? 'QR Code ' : ''}Payment of $${amount.toFixed(2)} sent successfully!`, 'payment-notification');
        }, speed === 'instant' ? 500 : speed === 'fast' ? 2000 : 5000);
        
        saveWallet();
        updateWalletUI();
        updateDisplay();
        
        return true;
    }
    
    // ======================
    // QR Code Payment System
    // ======================
    
    /**
     * Generate QR Code for payment
     * @param {number} amount - Payment amount
     * @param {string} note - Payment note
     */
    function generateQRCode(amount, note = '') {
        // Store current QR code data
        currentQRCode = {
            recipient: userWallet.id,
            amount: amount,
            note: note,
            timestamp: new Date().toISOString()
        };
        
        // Update UI
        qrAmount.textContent = `$${amount.toFixed(2)}`;
        qrRecipient.textContent = userWallet.id;
        
        // Generate QR code (simplified for demo)
        const qrCtx = qrcodeCanvas.getContext('2d');
        qrCtx.fillStyle = 'white';
        qrCtx.fillRect(0, 0, 200, 200);
        
        // Draw a simple pattern to represent QR code
        qrCtx.fillStyle = 'black';
        const cellSize = 10;
        for (let x = 0; x < 20; x++) {
            for (let y = 0; y < 20; y++) {
                if ((x + y) % 2 === 0 || Math.random() > 0.5) {
                    qrCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Draw position markers (corners)
        const markerSize = 7;
        // Top-left
        for (let x = 0; x < markerSize; x++) {
            for (let y = 0; y < markerSize; y++) {
                if (x === 0 || y === 0 || x === markerSize - 1 || y === markerSize - 1 || 
                    (x > 1 && x < markerSize - 2 && y > 1 && y < markerSize - 2)) {
                    qrCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        // Top-right
        for (let x = 13; x < 20; x++) {
            for (let y = 0; y < markerSize; y++) {
                if (x === 13 || y === 0 || x === 19 || y === markerSize - 1 || 
                    (x < 18 && x > 14 && y > 1 && y < markerSize - 2)) {
                    qrCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        // Bottom-left
        for (let x = 0; x < markerSize; x++) {
            for (let y = 13; y < 20; y++) {
                if (x === 0 || y === 13 || x === markerSize - 1 || y === 19 || 
                    (x > 1 && x < markerSize - 2 && y < 18 && y > 14)) {
                    qrCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Show modal
        qrcodeModal.style.display = 'flex';
        showNotification('QR Code generated! Show this to the payer.', 'qrcode-notification');
    }
    
    /**
     * Process QR Code payment
     * @param {Object} qrData - QR Code data
     */
    function processQRCodePayment(qrData) {
        // In a real implementation, this would validate the QR code
        // For demo, we'll use the currentQRCode data
        
        if (!qrData || !qrData.recipient || !qrData.amount) {
            showNotification('Invalid QR Code!', 'qrcode-notification');
            return false;
        }
        
        // Check if user is trying to pay themselves
        if (qrData.recipient === userWallet.id) {
            showNotification('Cannot pay yourself!', 'qrcode-notification');
            return false;
        }
        
        // Process payment with standard speed (no fee for QR payments)
        return processPayment(qrData.recipient, qrData.amount, qrData.note, 'standard', 'qrcode');
    }
    
    // ======================
    // Transaction Modal
    // ======================
    
    // Close transaction modal
    closeTxModal.addEventListener('click', () => {
        txModal.style.display = 'none';
    });
    
    // Transaction form submission
    txForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const from = document.getElementById('txFrom').value;
        const to = document.getElementById('txTo').value;
        const amount = parseFloat(document.getElementById('txAmount').value).toFixed(2);
        const description = document.getElementById('txDesc').value || 'Manual Transaction';
        
        const newTx = {
            id: `TXN-${10000 + transactions.length}`,
            from, to, amount, description,
            timestamp: new Date().toISOString()
        };
        
        addTransaction(newTx);
        txModal.style.display = 'none';
        txForm.reset();
        showNotification('Transaction added successfully!');
    });
    
    // ======================
    // Payment Modal
    // ======================
    
    // Close payment modal
    closePaymentModal.addEventListener('click', () => {
        paymentModal.style.display = 'none';
    });
    
    // Payment form submission
    paymentForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const recipient = document.getElementById('paymentRecipient').value;
        const amount = parseFloat(document.getElementById('paymentAmount').value);
        const note = document.getElementById('paymentNote').value;
        const speed = document.getElementById('paymentSpeed').value;
        
        if (processPayment(recipient, amount, note, speed)) {
            paymentModal.style.display = 'none';
            paymentForm.reset();
        }
    });
    
    // ======================
    // QR Code Modal
    // ======================
    
    // Close QR modal
    closeQRModal.addEventListener('click', () => {
        qrcodeModal.style.display = 'none';
    });
    
    // ======================
    // Scan QR Code Modal
    // ======================
    
    // Close scan modal
    closeScanModal.addEventListener('click', () => {
        scanModal.style.display = 'none';
    });
    
    // Simulate QR scan
    simulateScan.addEventListener('click', () => {
        // In a real implementation, this would use device camera to scan QR code
        // For demo, we'll simulate a successful scan with sample data
        
        // Create sample QR data (in a real app, this would come from scanning)
        const sampleQRData = {
            recipient: 'DL-ABCD-EFGH-IJKL', // Sample recipient
            amount: 25.00,                  // Sample amount
            note: 'Coffee',                 // Sample note
            timestamp: new Date().toISOString()
        };
        
        // Process the payment
        if (processQRCodePayment(sampleQRData)) {
            scanModal.style.display = 'none';
            showNotification('QR Code payment processed successfully!', 'qrcode-notification');
        }
    });
    
    // ======================
    // Notification System
    // ======================
    
    /**
     * Show a notification message
     * @param {string} message - The message to display
     * @param {string} type - Notification type (default, payment, or qrcode)
     */
    function showNotification(message, type = 'default') {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = 'notification';
        
        if (type === 'payment') {
            notification.classList.add('payment-notification');
        } else if (type === 'qrcode') {
            notification.classList.add('qrcode-notification');
        }
        
        notification.classList.add('show');
        
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }
    
    // ======================
    // Canvas Management
    // ======================
    
    /**
     * Resize canvas to fit window
     * Centers the view and triggers redraw
     */
    function resizeCanvas() {
        if (!isAuthenticated) return;
        
        const controlsHeight = document.getElementById('controls').offsetHeight;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - controlsHeight;
        canvas.style.marginTop = `${controlsHeight}px`;
        centerView();
        requestDraw();
    }
    
    window.addEventListener('resize', resizeCanvas);
    
    // ======================
    // Event Listeners
    // ======================
    
    // Add transaction button
    addTxButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        txModal.style.display = 'flex';
    });
    
    // Payment button
    paymentButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        paymentModal.style.display = 'flex';
    });
    
    // Wallet button
    walletButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        showWallet();
    });
    
    // Generate QR button
    generateQRButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        
        const amount = parseFloat(prompt('Enter amount for QR code:', '10.00'));
        if (!isNaN(amount) && amount > 0) {
            const note = prompt('Enter note for payment (optional):', '') || '';
            generateQRCode(amount, note);
        }
    });
    
    // Scan QR button
    scanQRButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        scanModal.style.display = 'flex';
    });
    
    // Generate galaxy button
    generateButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        generateGalaxy(5000);
    });
    
    // Clear ledger button
    clearButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        if (confirm('Are you sure you want to clear the entire ledger?')) {
            clearLedger();
            showNotification('Ledger cleared');
        }
    });
    
    // Save ledger button
    saveButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        try {
            localStorage.setItem('blockchainLedger', JSON.stringify(transactions));
            showNotification('Ledger saved successfully!');
        } catch (e) {
            showNotification('Failed to save ledger: ' + e.message);
        }
    });
    
    // Load ledger button
    loadButton.addEventListener('click', () => {
        if (!isAuthenticated) return;
        try {
            const saved = localStorage.getItem('blockchainLedger');
            if (saved) {
                const loadedTransactions = JSON.parse(saved);
                clearLedger();
                loadedTransactions.forEach(tx => {
                    transactions.push(tx);
                    blocks.push({ type: 'source', txId: tx.id, data: tx });
                    blocks.push({ type: 'destination', txId: tx.id, data: tx });
                });
                updateDisplay();
                showNotification('Ledger loaded successfully!');
            } else {
                showNotification('No saved ledger found');
            }
        } catch (e) {
            showNotification('Failed to load ledger: ' + e.message);
        }
    });
    
    // History mode toggle
    historyModeButton.addEventListener('click', toggleHistoryMode);
    
    // Fork timeline button
    forkButton.addEventListener('click', createFork);
    
    // Search input
    searchBox.addEventListener('input', (e) => { 
        searchQuery = e.target.value.toLowerCase(); 
        requestDraw(); 
    });
    
    // Filter select
    filterSelect.addEventListener('change', (e) => {
        filterType = e.target.value;
        requestDraw();
    });
    
    // Zoom slider
    zoomSlider.addEventListener('input', (e) => { 
        zoom = parseFloat(e.target.value); 
        zoomDisplay.textContent = zoom.toFixed(1) + 'x';
        updateZoomInfo();
        requestDraw(); 
    });
    
    // ======================
    // Keyboard Shortcuts
    // ======================
    
    document.addEventListener('keydown', (e) => {
        if (!isAuthenticated) return;
        
        if (e.ctrlKey || e.metaKey) {
            switch(e.key) {
                case 's':
                    e.preventDefault();
                    saveButton.click();
                    break;
                case 'o':
                    e.preventDefault();
                    loadButton.click();
                    break;
                case '=':
                case '+':
                    e.preventDefault();
                    zoomSlider.value = Math.min(5, zoom + 0.1);
                    zoomSlider.dispatchEvent(new Event('input'));
                    break;
                case '-':
                    e.preventDefault();
                    zoomSlider.value = Math.max(0.1, zoom - 0.1);
                    zoomSlider.dispatchEvent(new Event('input'));
                    break;
            }
        }
    });
    
    // ======================
    // Canvas Interaction
    // ======================
    
    canvas.addEventListener('mousedown', (e) => { 
        if (!isAuthenticated) return;
        dragging = true; 
        lastMousePos = { x: e.clientX, y: e.clientY }; 
    });
    
    canvas.addEventListener('mouseup', () => { 
        dragging = false; 
        canvas.style.cursor = 'grab'; 
    });
    
    canvas.addEventListener('mouseleave', () => { 
        dragging = false; 
        hoveredBlockIndex = -1; 
        requestDraw(); 
    });
    
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('wheel', handleScroll, { passive: false });
    
    /**
     * Handle mouse movement for dragging and hover effects
     * @param {MouseEvent} e - Mouse event
     */
    function handleMouseMove(e) {
        if (!isAuthenticated) return;
        
        if (dragging) {
            canvas.style.cursor = 'grabbing';
            dragOffset.x += e.clientX - lastMousePos.x;
            dragOffset.y += e.clientY - lastMousePos.y;
            lastMousePos = { x: e.clientX, y: e.clientY };
            requestDraw();
        } else {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const newHoveredIndex = getBlockAtPosition(mouseX, mouseY);
            if (newHoveredIndex !== hoveredBlockIndex) {
                hoveredBlockIndex = newHoveredIndex;
                canvas.style.cursor = hoveredBlockIndex >= 0 ? 'pointer' : 'grab';
                requestDraw();
            }
        }
    }
    
    /**
     * Handle canvas clicks for block selection
     */
    function handleClick() {
        if (!isAuthenticated) return;
        
        if (hoveredBlockIndex !== -1) {
            selectedTxId = blocks[hoveredBlockIndex].txId;
            showDetails(selectedTxId);
            requestDraw();
        } else {
            detailsPanel.style.display = 'none';
            walletPanel.style.display = 'none';
            selectedTxId = null;
            requestDraw();
        }
    }
    
    /**
     * Handle mouse wheel for zooming and panning
     * @param {WheelEvent} e - Wheel event
     */
    function handleScroll(e) {
        if (!isAuthenticated) return;
        
        e.preventDefault();
        if (e.ctrlKey) {
            // Zoom
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(5, zoom * zoomFactor));
            zoomSlider.value = zoom;
            zoomDisplay.textContent = zoom.toFixed(1) + 'x';
            updateZoomInfo();
        } else {
            // Pan
            dragOffset.x -= e.deltaX;
            dragOffset.y -= e.deltaY;
        }
        requestDraw();
    }
    
    // ======================
    // Core Functions
    // ======================
    
    /**
     * Toggle history mode
     */
    function toggleHistoryMode() {
        historyMode = !historyMode;
        historyModeButton.classList.toggle('active', historyMode);
        historyModeButton.classList.toggle('history-mode', historyMode);
        document.getElementById('historyActions').style.display = historyMode ? 'block' : 'none';
        requestDraw();
    }
    
    /**
     * Create a fork from selected transaction
     */
    function createFork() {
        if (selectedTxId) {
            forkFromHere();
        } else {
            showNotification('Select a transaction first to fork from that point!');
        }
    }
    
    /**
     * Generate a galaxy of transactions
     * @param {number} count - Number of transactions to generate
     */
    function generateGalaxy(count) {
        if (!isAuthenticated) return;
        
        const names = ["Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Heidi", "Ivan", "Judy", "Kevin", "Luna", "Mike", "Nina", "Oscar", "Penny"];
        const items = ["Data Packets", "Compute Cycles", "Storage Units", "API Call", "Token Transfer", "Smart Contract", "NFT Mint", "DeFi Swap", "Governance Vote", "Staking Reward"];
        
        console.log(`Generating ${count} transactions...`);
        
        // Use batch processing for better performance
        const batchSize = 1000;
        let processed = 0;
        
        function processBatch() {
            const end = Math.min(processed + batchSize, count);
            for (let i = processed; i < end; i++) {
                const from = names[Math.floor(Math.random() * names.length)];
                let to;
                do { to = names[Math.floor(Math.random() * names.length)]; } while (from === to);
                const amount = (Math.random() * 1000 + 1).toFixed(2);
                const description = items[Math.floor(Math.random() * items.length)];
                const timestamp = new Date(Date.now() - (count - i) * 60000).toISOString();
                
                const newTx = {
                    id: `TXN-${10000 + transactions.length}`, 
                    from, to, amount, description, timestamp
                };
                
                transactions.push(newTx);
                blocks.push({ type: 'source', txId: newTx.id, data: newTx });
                blocks.push({ type: 'destination', txId: newTx.id, data: newTx });
            }
            
            processed = end;
            updateDisplay();
            
            if (processed < count) {
                setTimeout(processBatch, 0); // Let UI breathe
            } else {
                console.log(`Galaxy generated with ${transactions.length} transactions!`);
                showNotification(`Generated ${count} transactions!`);
            }
        }
        
        processBatch();
    }
    
    /**
     * Add a transaction to the ledger
     * @param {Object} txData - Transaction data
     */
    function addTransaction(txData) {
        if (!isAuthenticated) return;
        
        const newTx = txData || {
            id: `TXN-${10000 + transactions.length}`,
            from: "Unknown",
            to: "Unknown",
            amount: (Math.random() * 500 + 10).toFixed(2),
            description: "Manual Transaction",
            timestamp: new Date().toISOString()
        };
        
        transactions.push(newTx);
        blocks.push({ type: 'source', txId: newTx.id, data: newTx });
        blocks.push({ type: 'destination', txId: newTx.id, data: newTx });
        updateDisplay();
    }
    
    /**
     * Update the display with current transaction count
     */
    function updateDisplay() {
        countDisplay.textContent = `Transactions: ${transactions.length.toLocaleString()}`;
        requestDraw();
    }
    
    /**
     * Clear all transactions from the ledger
     */
    function clearLedger() {
        if (!isAuthenticated) return;
        
        transactions = [];
        blocks = [];
        dragOffset = { x: 0, y: 0 };
        selectedTxId = null;
        detailsPanel.style.display = 'none';
        walletPanel.style.display = 'none';
        updateDisplay();
    }
    
    /**
     * Center the view on the ledger
     */
    function centerView() {
        if (!isAuthenticated || blocks.length === 0) return;
        
        // Calculate the total dimensions of the ledger
        const blockSize = 40 * zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        const cols = Math.max(1, Math.floor(canvas.width / (hexWidth * 0.75)));
        const rows = Math.ceil(blocks.length / cols);
        const layoutWidth = cols * hexWidth * 0.75;
        const layoutHeight = rows * hexHeight;
        
        // Center the view
        dragOffset.x = 0;
        dragOffset.y = 0;
    }
    
    /**
     * Request a redraw on the next animation frame
     */
    function requestDraw() {
        needsRedraw = true;
    }
    
    /**
     * Animation loop for efficient rendering
     */
    function animate() {
        if (needsRedraw) {
            draw();
            needsRedraw = false;
        }
        animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start the animation loop
    animate();
    
    // ======================
    // Rendering Functions
    // ======================
    
    /**
     * Main drawing function - dispatches to appropriate renderer
     */
    function draw() {
        if (!isAuthenticated) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (blocks.length === 0) return;
        
        if (zoom < PIXEL_THRESHOLD) {
            drawGalaxyView();
        } else if (zoom < SIMPLE_THRESHOLD) {
            drawClusterView();
        } else {
            drawBlockView();
        }
    }
    
    /**
     * Draw galaxy view - each transaction as a pixel
     */
    function drawGalaxyView() {
        const cols = Math.max(1, Math.floor(canvas.width / 2));
        const spacing = 2;
        
        ctx.imageSmoothingEnabled = false;
        
        // Only process visible blocks for performance
        const startIdx = Math.max(0, Math.floor((-dragOffset.y - canvas.height/4) / spacing) * cols);
        const endIdx = Math.min(blocks.length, Math.ceil((canvas.height - dragOffset.y + canvas.height/4) / spacing) * cols);
        
        for (let index = startIdx; index < endIdx; index++) {
            const block = blocks[index];
            const col = index % cols;
            const row = Math.floor(index / cols);
            const x = col * spacing + dragOffset.x + canvas.width / 4;
            const y = row * spacing + dragOffset.y + canvas.height / 4;
            
            // Skip if outside viewport
            if (x < -10 || x > canvas.width + 10 || y < -10 || y > canvas.height + 10) continue;
            
            // Apply filter
            if (filterType !== 'all' && block.type !== filterType) {
                if (filterType === 'payment' && block.data.type !== 'payment') continue;
                if (filterType === 'qrcode' && block.data.paymentType !== 'qrcode') continue;
                if (filterType !== 'payment' && filterType !== 'qrcode' && block.type !== filterType) continue;
            }
            
            const isSearched = searchQuery && (block.data.id.toLowerCase().includes(searchQuery) || 
                                             block.data.from.toLowerCase().includes(searchQuery) || 
                                             block.data.to.toLowerCase().includes(searchQuery));
            
            ctx.globalAlpha = 1.0;
            if (searchQuery && !isSearched) ctx.globalAlpha = 0.1;
            
            // Draw glowing pixel
            let color;
            if (block.data.type === 'payment') {
                color = block.data.paymentType === 'qrcode' ? '#2c3e50' : '#16a085'; // Different colors for payment types
            } else {
                color = block.type === 'source' ? '#3498db' : '#2ecc71';
            }
            
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 2;
            ctx.fillRect(x, y, 1, 1);
            ctx.shadowBlur = 0;
        }
        
        ctx.globalAlpha = 1.0;
        ctx.imageSmoothingEnabled = true;
    }
    
    /**
     * Draw cluster view - simple hexagons
     */
    function drawClusterView() {
        const blockSize = 30 * zoom;
        const hexWidth = blockSize * 1.5;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Calculate visible range
        const startRow = Math.max(0, Math.floor((-dragOffset.y - canvas.height) / hexHeight));
        const endRow = Math.ceil(blocks.length / Math.max(1, Math.floor(canvas.width / (hexWidth * 0.75))));
        const startIdx = startRow * Math.floor(canvas.width / (hexWidth * 0.75));
        const endIdx = Math.min(blocks.length, endRow * Math.floor(canvas.width / (hexWidth * 0.75)));
        
        // Draw connections first
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rung-color').trim();
        ctx.lineWidth = 1;
        
        for (let i = 0; i < transactions.length; i++) {
            const tx = transactions[i];
            const sourceIndex = blocks.findIndex(b => b.txId === tx.id && b.type === 'source');
            const destIndex = blocks.findIndex(b => b.txId === tx.id && b.type === 'destination');
            if (sourceIndex === -1 || destIndex === -1) continue;
            
            const posA = getBlockPosition(sourceIndex, hexWidth, hexHeight);
            const posB = getBlockPosition(destIndex, hexWidth, hexHeight);
            
            // Skip if both are outside viewport
            if ((posA.x < -50 && posB.x < -50) || 
                (posA.x > canvas.width + 50 && posB.x > canvas.width + 50) ||
                (posA.y < -50 && posB.y < -50) || 
                (posA.y > canvas.height + 50 && posB.y > canvas.height + 50)) continue;
            
            const isSearched = searchQuery && (tx.id.toLowerCase().includes(searchQuery) || 
                                             tx.from.toLowerCase().includes(searchQuery) || 
                                             tx.to.toLowerCase().includes(searchQuery));
            
            ctx.globalAlpha = 1.0;
            if (searchQuery && !isSearched) ctx.globalAlpha = 0.2;
            
            // Use different color for payment transactions
            if (tx.type === 'payment') {
                ctx.strokeStyle = tx.paymentType === 'qrcode' ? 
                    getComputedStyle(document.documentElement).getPropertyValue('--qrcode-color').trim() :
                    getComputedStyle(document.documentElement).getPropertyValue('--payment-color').trim();
            }
            
            ctx.beginPath();
            ctx.moveTo(posA.x, posA.y);
            ctx.lineTo(posB.x, posB.y);
            ctx.stroke();
            
            // Reset color
            if (tx.type === 'payment') {
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rung-color').trim();
            }
        }
        
        // Draw simple hexagons
        for (let index = startIdx; index < endIdx; index++) {
            const block = blocks[index];
            const pos = getBlockPosition(index, hexWidth, hexHeight);
            
            // Skip if outside viewport
            if (pos.x < -50 || pos.x > canvas.width + 50 || pos.y < -50 || pos.y > canvas.height + 50) continue;
            
            // Apply filter
            if (filterType !== 'all' && block.type !== filterType) {
                if (filterType === 'payment' && block.data.type !== 'payment') continue;
                if (filterType === 'qrcode' && block.data.paymentType !== 'qrcode') continue;
                if (filterType !== 'payment' && filterType !== 'qrcode' && block.type !== filterType) continue;
            }
            
            const isSearched = searchQuery && (block.data.id.toLowerCase().includes(searchQuery) || 
                                             block.data.from.toLowerCase().includes(searchQuery) || 
                                             block.data.to.toLowerCase().includes(searchQuery));
            
            ctx.globalAlpha = 1.0;
            if (searchQuery && !isSearched) ctx.globalAlpha = 0.2;
            
            // Use different color for payment transactions
            if (block.data.type === 'payment') {
                ctx.fillStyle = block.data.paymentType === 'qrcode' ? 
                    getComputedStyle(document.documentElement).getPropertyValue('--qrcode-color').trim() :
                    getComputedStyle(document.documentElement).getPropertyValue('--payment-color').trim();
            } else {
                ctx.fillStyle = block.type === 'source' ? 
                    getComputedStyle(document.documentElement).getPropertyValue('--source-color').trim() : 
                    getComputedStyle(document.documentElement).getPropertyValue('--dest-color').trim();
            }
            
            // Draw simple hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                let angle = (Math.PI / 3) * i;
                let px = pos.x + blockSize * Math.cos(angle);
                let py = pos.y + blockSize * Math.sin(angle);
                i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.globalAlpha = 1.0;
    }
    
    /**
     * Draw block view - detailed hexagons with text
     */
    function drawBlockView() {
        const blockSize = 40 * zoom;
        const hexHeight = Math.sqrt(3) * blockSize;
        const hexWidth = 2 * blockSize;
        
        // Calculate visible range
        const startRow = Math.max(0, Math.floor((-dragOffset.y - canvas.height) / hexHeight));
        const endRow = Math.ceil(blocks.length / Math.max(1, Math.floor(canvas.width / (hexWidth * 0.75))));
        const startIdx = startRow * Math.floor(canvas.width / (hexWidth * 0.75));
        const endIdx = Math.min(blocks.length, endRow * Math.floor(canvas.width / (hexWidth * 0.75)));
        
        // Draw connections
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--rung-color').trim();
        ctx.lineWidth = 2 * zoom;
        
        for (let i = 0; i < transactions.length; i++) {
            const tx = transactions[i];
            const sourceIndex = blocks.findIndex(b => b.txId === tx.id && b.type === 'source');
            const destIndex = blocks.findIndex(b => b.txId === tx.id && b.type === 'destination');
            if (sourceIndex === -1 || destIndex === -1) continue;
            
            const posA = getBlockPosition(sourceIndex, hexWidth, hexHeight);
            const posB = getBlockPosition(destIndex, hexWidth, hexHeight);
            
            // Skip if both are outside viewport
            if ((posA.x < -50 && posB.x < -50) || 
                (posA.x > canvas.width + 50 && posB.x > canvas.width + 50) ||
                (posA.y < -50 && posB.y < -50) || 
                (posA.y > canvas.height + 50 && posB.y > canvas.height + 50)) continue;
            
            const isHovered = hoveredBlockIndex !== -1 && blocks[hoveredBlockIndex].txId === tx.id;
            const isSelected = selectedTxId === tx.id;
            const isSearched = searchQuery && (tx.id.toLowerCase().includes(searchQuery) || 
                                             tx.from.toLowerCase().includes(searchQuery) || 
                                             tx.to.toLowerCase().includes(searchQuery));
            ctx.globalAlpha = 1.0;
            if (searchQuery && !isSearched) ctx.globalAlpha = 0.1;
            ctx.beginPath();
            ctx.moveTo(posA.x, posA.y);
            ctx.lineTo(posB.x, posB.y);
            
            ctx.lineWidth = (isHovered || isSelected) ? 5 * zoom : 2 * zoom;
            
            // Use different color for payment transactions
            if (tx.type === 'payment') {
                ctx.strokeStyle = (isHovered || isSelected) ? 
                    getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim() : 
                    (tx.paymentType === 'qrcode' ? 
                        getComputedStyle(document.documentElement).getPropertyValue('--qrcode-color').trim() :
                        getComputedStyle(document.documentElement).getPropertyValue('--payment-color').trim());
            } else {
                ctx.strokeStyle = (isHovered || isSelected) ? 
                    getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim() : 
                    getComputedStyle(document.documentElement).getPropertyValue('--rung-color').trim();
            }
            
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
        
        // Draw detailed hexagons
        for (let index = startIdx; index < endIdx; index++) {
            const block = blocks[index];
            const pos = getBlockPosition(index, hexWidth, hexHeight);
            
            // Skip if outside viewport
            if (pos.x < -50 || pos.x > canvas.width + 50 || pos.y < -50 || pos.y > canvas.height + 50) continue;
            
            // Apply filter
            if (filterType !== 'all' && block.type !== filterType) {
                if (filterType === 'payment' && block.data.type !== 'payment') continue;
                if (filterType === 'qrcode' && block.data.paymentType !== 'qrcode') continue;
                if (filterType !== 'payment' && filterType !== 'qrcode' && block.type !== filterType) continue;
            }
            
            drawDetailedHexBlock(block, pos.x, pos.y, index, blockSize);
        }
    }
    
    /**
     * Draw a detailed hexagon block
     * @param {Object} block - Block object
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} index - Block index
     * @param {number} blockSize - Size of the block
     */
    function drawDetailedHexBlock(block, x, y, index, blockSize) {
        const isHovered = hoveredBlockIndex !== -1 && blocks[hoveredBlockIndex].txId === block.txId;
        const isSelected = selectedTxId === block.txId;
        const isSearched = searchQuery && (block.data.id.toLowerCase().includes(searchQuery) || 
                                         block.data.from.toLowerCase().includes(searchQuery) || 
                                         block.data.to.toLowerCase().includes(searchQuery));
        ctx.globalAlpha = 1.0;
        if (searchQuery && !isSearched) ctx.globalAlpha = 0.1;
        ctx.save();
        
        // Use different color for payment transactions
        if (block.data.type === 'payment') {
            ctx.fillStyle = block.data.paymentType === 'qrcode' ? 
                getComputedStyle(document.documentElement).getPropertyValue('--qrcode-color').trim() :
                getComputedStyle(document.documentElement).getPropertyValue('--payment-color').trim();
        } else {
            ctx.fillStyle = block.type === 'source' ? 
                getComputedStyle(document.documentElement).getPropertyValue('--source-color').trim() : 
                getComputedStyle(document.documentElement).getPropertyValue('--dest-color').trim();
        }
        
        if (historyMode) {
            ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--fork-color').trim();
            ctx.shadowBlur = 5;
        }
        
        if (isHovered || isSelected) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim();
            ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim();
            ctx.shadowBlur = 10;
        }
        
        // Draw hexagon
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            let angle = (Math.PI / 3) * i;
            let px = x + blockSize * Math.cos(angle);
            let py = y + blockSize * Math.sin(angle);
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        if (isSelected) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
        
        // Draw text if zoom is high enough
        if (zoom > 0.8) {
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const fontSize = Math.max(8, blockSize * 0.15 * zoom);
            ctx.font = `bold ${fontSize}px Segoe UI`;
            
            let label = block.type === 'source' ? 'FROM' : 'TO';
            if (block.data.type === 'payment') {
                label = block.type === 'source' ? 'PAYER' : 'PAYEE';
                if (block.data.paymentType === 'qrcode') {
                    label = block.type === 'source' ? 'QR PAYER' : 'QR PAYEE';
                }
            }
            
            ctx.fillText(label, x, y - fontSize * 1.2);
            ctx.font = `${fontSize * 0.8}px Segoe UI`;
            
            let displayText = block.type === 'source' ? block.data.from : block.data.to;
            if (displayText.length > 10) {
                displayText = displayText.substring(0, 10) + '...';
            }
            
            ctx.fillText(displayText, x, y);
            if (zoom > 1.2) {
                ctx.fillText(`ID: ${block.data.id.slice(-4)}`, x, y + fontSize * 1.2);
            }
        }
        
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }
    
    // ======================
    // Utility Functions
    // ======================
    
    /**
     * Get the position of a block in the grid
     * @param {number} index - Block index
     * @param {number} hexWidth - Width of hexagon
     * @param {number} hexHeight - Height of hexagon
     * @returns {Object} Position {x, y}
     */
    function getBlockPosition(index, hexWidth, hexHeight) {
        const cols = Math.max(1, Math.floor(canvas.width / (hexWidth * 0.75)));
        const col = index % cols;
        const row = Math.floor(index / cols);
        
        const layoutWidth = cols * hexWidth * 0.75;
        const layoutHeight = Math.ceil(blocks.length / cols) * hexHeight;
        const centerOffsetX = canvas.width / 2 - layoutWidth / 2;
        const centerOffsetY = canvas.height / 2 - layoutHeight / 2;
        
        const x = col * hexWidth * 0.75 + dragOffset.x + centerOffsetX;
        const y = row * hexHeight + (col % 2 === 0 ? 0 : hexHeight / 2) + dragOffset.y + centerOffsetY;
        return { x, y };
    }
    
    /**
     * Get the block at a specific position
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @returns {number} Block index or -1 if not found
     */
    function getBlockAtPosition(x, y) {
        if (zoom < SIMPLE_THRESHOLD) return -1; // No interaction in pixel/cluster view
        
        const blockSize = 40 * zoom;
        const hexWidth = 2 * blockSize;
        const hexHeight = Math.sqrt(3) * blockSize;
        
        // Only check visible blocks
        const startRow = Math.max(0, Math.floor((-dragOffset.y - canvas.height) / hexHeight));
        const endRow = Math.ceil(blocks.length / Math.max(1, Math.floor(canvas.width / (hexWidth * 0.75))));
        const startIdx = startRow * Math.floor(canvas.width / (hexWidth * 0.75));
        const endIdx = Math.min(blocks.length, endRow * Math.floor(canvas.width / (hexWidth * 0.75)));
        
        for (let i = endIdx - 1; i >= startIdx; i--) {
            const pos = getBlockPosition(i, hexWidth, hexHeight);
            const dx = x - pos.x;
            const dy = y - pos.y;
            if (dx * dx + dy * dy < blockSize * blockSize) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * Show transaction details in the details panel
     * @param {string} txId - Transaction ID
     */
    function showDetails(txId) {
        const tx = transactions.find(t => t.id === txId);
        if (!tx) return;
        detailsPanel.style.display = 'block';
        walletPanel.style.display = 'none';
        document.getElementById('detailId').textContent = tx.id;
        document.getElementById('detailFrom').textContent = tx.from;
        document.getElementById('detailTo').textContent = tx.to;
        document.getElementById('detailAmount').textContent = `$${tx.amount}`;
        document.getElementById('detailDesc').textContent = tx.description;
        document.getElementById('detailTs').textContent = new Date(tx.timestamp).toLocaleString();
        
        // Show fee for payment transactions
        if (tx.type === 'payment' && tx.fee) {
            document.getElementById('detailDesc').textContent = `${tx.description} (Fee: $${tx.fee.toFixed(2)})`;
        }
        
        // Show payment type for QR code payments
        if (tx.paymentType === 'qrcode') {
            document.getElementById('detailDesc').textContent = `${tx.description} (QR Code Payment)`;
        }
    }
    
    /**
     * Update zoom info display
     */
    function updateZoomInfo() {
        const info = document.getElementById('zoomInfo');
        if (zoom < PIXEL_THRESHOLD) {
            info.innerHTML = '<strong>Galaxy View</strong><br>Each pixel represents a transaction. Blue = source, Green = destination, Teal = payment, Dark blue = QR payment.';
        } else if (zoom < SIMPLE_THRESHOLD) {
            info.innerHTML = '<strong>Cluster View</strong><br>Simple hexagons showing transaction structure.';
        } else {
            info.innerHTML = '<strong>Block View</strong><br>Full transaction details and interactions.';
        }
    }
    
    // ======================
    // History Manipulation
    // ======================
    
    /**
     * Move a transaction (placeholder)
     */
    function moveTransaction() {
        showNotification('Move functionality: Drag this transaction to reorder the timeline!');
    }
    
    /**
     * Delete a transaction from history
     */
    function deleteTransaction() {
        if (!isAuthenticated) return;
        
        if (confirm('Delete this transaction from history?')) {
            const txIndex = transactions.findIndex(t => t.id === selectedTxId);
            if (txIndex !== -1) {
                transactions.splice(txIndex, 1);
                blocks = blocks.filter(b => b.txId !== selectedTxId);
                selectedTxId = null;
                detailsPanel.style.display = 'none';
                updateDisplay();
                showNotification('Transaction deleted! History has been rewritten.');
            }
        }
    }
    
    /**
     * Fork timeline from selected transaction
     */
    function forkFromHere() {
        if (!isAuthenticated) return;
        
        const tx = transactions.find(t => t.id === selectedTxId);
        if (tx) {
            const forkTx = {
                ...tx,
                id: tx.id + '-FORK',
                description: tx.description + ' (Forked)',
                timestamp: new Date().toISOString()
            };
            addTransaction(forkTx);
            showNotification('Timeline forked! This creates an alternate history branch.');
        }
    }
    
    // ======================
    // Initialize Application
    // ======================
    
    // Check PIN on load
    checkPin();
  </script>
</body>
</html>
